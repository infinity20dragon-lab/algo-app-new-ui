{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"sources":["file:///mnt/g/files/documents/webdev/algo-app/src/lib/firebase/config.ts"],"sourcesContent":["import { initializeApp, getApps } from \"firebase/app\";\nimport { getAuth } from \"firebase/auth\";\nimport { getFirestore } from \"firebase/firestore\";\nimport { getStorage } from \"firebase/storage\";\nimport { getDatabase } from \"firebase/database\";\n\nconst firebaseConfig = {\n  apiKey: process.env.NEXT_PUBLIC_FIREBASE_API_KEY,\n  authDomain: process.env.NEXT_PUBLIC_FIREBASE_AUTH_DOMAIN,\n  projectId: process.env.NEXT_PUBLIC_FIREBASE_PROJECT_ID,\n  storageBucket: process.env.NEXT_PUBLIC_FIREBASE_STORAGE_BUCKET,\n  messagingSenderId: process.env.NEXT_PUBLIC_FIREBASE_MESSAGING_SENDER_ID,\n  appId: process.env.NEXT_PUBLIC_FIREBASE_APP_ID,\n  measurementId: process.env.NEXT_PUBLIC_FIREBASE_MEASUREMENT_ID,\n  databaseURL: process.env.NEXT_PUBLIC_FIREBASE_DATABASE_URL,\n};\n\n// Initialize Firebase (prevent multiple initializations)\nconst app = getApps().length === 0 ? initializeApp(firebaseConfig) : getApps()[0];\n\nexport const auth = getAuth(app);\nexport const db = getFirestore(app);\nexport const storage = getStorage(app);\nexport const realtimeDb = getDatabase(app);\n\nexport default app;\n"],"names":[],"mappings":";;;;;;;;;;;;AAOU;AAPV;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;;;;;;AAEA,MAAM,iBAAiB;IACrB,MAAM;IACN,UAAU;IACV,SAAS;IACT,aAAa;IACb,iBAAiB;IACjB,KAAK;IACL,aAAa;IACb,WAAW;AACb;AAEA,yDAAyD;AACzD,MAAM,MAAM,IAAA,8KAAO,IAAG,MAAM,KAAK,IAAI,IAAA,oLAAa,EAAC,kBAAkB,IAAA,8KAAO,GAAE,CAAC,EAAE;AAE1E,MAAM,OAAO,IAAA,wKAAO,EAAC;AACrB,MAAM,KAAK,IAAA,kLAAY,EAAC;AACxB,MAAM,UAAU,IAAA,8KAAU,EAAC;AAC3B,MAAM,aAAa,IAAA,gLAAW,EAAC;uCAEvB"}},
    {"offset": {"line": 56, "column": 0}, "map": {"version":3,"sources":["file:///mnt/g/files/documents/webdev/algo-app/src/lib/firebase/users.ts"],"sourcesContent":["import { doc, getDoc, setDoc, updateDoc } from \"firebase/firestore\";\nimport { db } from \"./config\";\n\nexport interface UserProfile {\n  uid: string;\n  email: string;\n  displayName: string;\n  role: \"user\" | \"admin\";\n  createdAt: Date;\n  lastLogin: Date;\n}\n\n/**\n * Get user profile from Firestore\n */\nexport async function getUserProfile(uid: string): Promise<UserProfile | null> {\n  try {\n    const docRef = doc(db, \"users\", uid);\n    const snapshot = await getDoc(docRef);\n\n    if (!snapshot.exists()) {\n      return null;\n    }\n\n    const data = snapshot.data();\n    return {\n      uid: snapshot.id,\n      email: data.email,\n      displayName: data.displayName || data.email?.split(\"@\")[0] || \"User\",\n      role: data.role || \"user\",\n      createdAt: data.createdAt?.toDate() || new Date(),\n      lastLogin: data.lastLogin?.toDate() || new Date(),\n    };\n  } catch (error) {\n    console.error(\"Error getting user profile:\", error);\n    return null;\n  }\n}\n\n/**\n * Create or update user profile on login\n */\nexport async function ensureUserProfile(\n  uid: string,\n  email: string\n): Promise<UserProfile> {\n  const docRef = doc(db, \"users\", uid);\n  const snapshot = await getDoc(docRef);\n\n  if (snapshot.exists()) {\n    // Update last login\n    await updateDoc(docRef, {\n      lastLogin: new Date(),\n    });\n\n    const data = snapshot.data();\n    return {\n      uid,\n      email: data.email,\n      displayName: data.displayName || email.split(\"@\")[0],\n      role: data.role || \"user\",\n      createdAt: data.createdAt?.toDate() || new Date(),\n      lastLogin: new Date(),\n    };\n  } else {\n    // Create new user profile\n    const newProfile: UserProfile = {\n      uid,\n      email,\n      displayName: email.split(\"@\")[0],\n      role: \"user\", // Default role\n      createdAt: new Date(),\n      lastLogin: new Date(),\n    };\n\n    await setDoc(docRef, {\n      ...newProfile,\n      createdAt: new Date(),\n      lastLogin: new Date(),\n    });\n\n    return newProfile;\n  }\n}\n\n/**\n * Update user role (admin only operation)\n */\nexport async function updateUserRole(\n  uid: string,\n  role: \"user\" | \"admin\"\n): Promise<void> {\n  const docRef = doc(db, \"users\", uid);\n  await updateDoc(docRef, { role });\n}\n"],"names":[],"mappings":";;;;;;;;AAAA;AAAA;AACA;;;AAcO,eAAe,eAAe,GAAW;IAC9C,IAAI;QACF,MAAM,SAAS,IAAA,yKAAG,EAAC,yIAAE,EAAE,SAAS;QAChC,MAAM,WAAW,MAAM,IAAA,4KAAM,EAAC;QAE9B,IAAI,CAAC,SAAS,MAAM,IAAI;YACtB,OAAO;QACT;QAEA,MAAM,OAAO,SAAS,IAAI;QAC1B,OAAO;YACL,KAAK,SAAS,EAAE;YAChB,OAAO,KAAK,KAAK;YACjB,aAAa,KAAK,WAAW,IAAI,KAAK,KAAK,EAAE,MAAM,IAAI,CAAC,EAAE,IAAI;YAC9D,MAAM,KAAK,IAAI,IAAI;YACnB,WAAW,KAAK,SAAS,EAAE,YAAY,IAAI;YAC3C,WAAW,KAAK,SAAS,EAAE,YAAY,IAAI;QAC7C;IACF,EAAE,OAAO,OAAO;QACd,QAAQ,KAAK,CAAC,+BAA+B;QAC7C,OAAO;IACT;AACF;AAKO,eAAe,kBACpB,GAAW,EACX,KAAa;IAEb,MAAM,SAAS,IAAA,yKAAG,EAAC,yIAAE,EAAE,SAAS;IAChC,MAAM,WAAW,MAAM,IAAA,4KAAM,EAAC;IAE9B,IAAI,SAAS,MAAM,IAAI;QACrB,oBAAoB;QACpB,MAAM,IAAA,+KAAS,EAAC,QAAQ;YACtB,WAAW,IAAI;QACjB;QAEA,MAAM,OAAO,SAAS,IAAI;QAC1B,OAAO;YACL;YACA,OAAO,KAAK,KAAK;YACjB,aAAa,KAAK,WAAW,IAAI,MAAM,KAAK,CAAC,IAAI,CAAC,EAAE;YACpD,MAAM,KAAK,IAAI,IAAI;YACnB,WAAW,KAAK,SAAS,EAAE,YAAY,IAAI;YAC3C,WAAW,IAAI;QACjB;IACF,OAAO;QACL,0BAA0B;QAC1B,MAAM,aAA0B;YAC9B;YACA;YACA,aAAa,MAAM,KAAK,CAAC,IAAI,CAAC,EAAE;YAChC,MAAM;YACN,WAAW,IAAI;YACf,WAAW,IAAI;QACjB;QAEA,MAAM,IAAA,4KAAM,EAAC,QAAQ;YACnB,GAAG,UAAU;YACb,WAAW,IAAI;YACf,WAAW,IAAI;QACjB;QAEA,OAAO;IACT;AACF;AAKO,eAAe,eACpB,GAAW,EACX,IAAsB;IAEtB,MAAM,SAAS,IAAA,yKAAG,EAAC,yIAAE,EAAE,SAAS;IAChC,MAAM,IAAA,+KAAS,EAAC,QAAQ;QAAE;IAAK;AACjC"}},
    {"offset": {"line": 138, "column": 0}, "map": {"version":3,"sources":["file:///mnt/g/files/documents/webdev/algo-app/src/contexts/auth-context.tsx"],"sourcesContent":["\"use client\";\n\nimport { createContext, useContext, useEffect, useState, type ReactNode } from \"react\";\nimport {\n  signInWithEmailAndPassword,\n  signOut as firebaseSignOut,\n  onAuthStateChanged,\n  type User,\n} from \"firebase/auth\";\nimport { auth } from \"@/lib/firebase/config\";\nimport { ensureUserProfile, type UserProfile } from \"@/lib/firebase/users\";\n\n// Extended user with role\nexport interface AuthUser extends User {\n  role?: \"user\" | \"admin\";\n  displayName: string | null;\n}\n\ninterface AuthContextType {\n  user: AuthUser | null;\n  loading: boolean;\n  signIn: (email: string, password: string) => Promise<void>;\n  signOut: () => Promise<void>;\n}\n\nconst AuthContext = createContext<AuthContextType | undefined>(undefined);\n\nexport function AuthProvider({ children }: { children: ReactNode }) {\n  const [user, setUser] = useState<AuthUser | null>(null);\n  const [loading, setLoading] = useState(true);\n\n  useEffect(() => {\n    const unsubscribe = onAuthStateChanged(auth, async (firebaseUser) => {\n      if (firebaseUser) {\n        // Get user profile with role\n        const profile = await ensureUserProfile(firebaseUser.uid, firebaseUser.email || \"\");\n\n        // Extend Firebase user with role\n        const extendedUser: AuthUser = {\n          ...firebaseUser,\n          role: profile.role,\n          displayName: profile.displayName,\n        };\n\n        setUser(extendedUser);\n      } else {\n        setUser(null);\n      }\n      setLoading(false);\n    });\n\n    return () => unsubscribe();\n  }, []);\n\n  const signIn = async (email: string, password: string) => {\n    await signInWithEmailAndPassword(auth, email, password);\n  };\n\n  const signOut = async () => {\n    await firebaseSignOut(auth);\n  };\n\n  return (\n    <AuthContext.Provider value={{ user, loading, signIn, signOut }}>\n      {children}\n    </AuthContext.Provider>\n  );\n}\n\nexport function useAuth() {\n  const context = useContext(AuthContext);\n  if (context === undefined) {\n    throw new Error(\"useAuth must be used within an AuthProvider\");\n  }\n  return context;\n}\n"],"names":[],"mappings":";;;;;;;AAEA;AACA;AAAA;AAMA;AACA;;;AAVA;;;;;AAyBA,MAAM,4BAAc,IAAA,8KAAa,EAA8B;AAExD,SAAS,aAAa,EAAE,QAAQ,EAA2B;;IAChE,MAAM,CAAC,MAAM,QAAQ,GAAG,IAAA,yKAAQ,EAAkB;IAClD,MAAM,CAAC,SAAS,WAAW,GAAG,IAAA,yKAAQ,EAAC;IAEvC,IAAA,0KAAS;kCAAC;YACR,MAAM,cAAc,IAAA,mLAAkB,EAAC,2IAAI;sDAAE,OAAO;oBAClD,IAAI,cAAc;wBAChB,6BAA6B;wBAC7B,MAAM,UAAU,MAAM,IAAA,uJAAiB,EAAC,aAAa,GAAG,EAAE,aAAa,KAAK,IAAI;wBAEhF,iCAAiC;wBACjC,MAAM,eAAyB;4BAC7B,GAAG,YAAY;4BACf,MAAM,QAAQ,IAAI;4BAClB,aAAa,QAAQ,WAAW;wBAClC;wBAEA,QAAQ;oBACV,OAAO;wBACL,QAAQ;oBACV;oBACA,WAAW;gBACb;;YAEA;0CAAO,IAAM;;QACf;iCAAG,EAAE;IAEL,MAAM,SAAS,OAAO,OAAe;QACnC,MAAM,IAAA,2LAA0B,EAAC,2IAAI,EAAE,OAAO;IAChD;IAEA,MAAM,UAAU;QACd,MAAM,IAAA,wKAAe,EAAC,2IAAI;IAC5B;IAEA,qBACE,6LAAC,YAAY,QAAQ;QAAC,OAAO;YAAE;YAAM;YAAS;YAAQ;QAAQ;kBAC3D;;;;;;AAGP;GAxCgB;KAAA;AA0CT,SAAS;;IACd,MAAM,UAAU,IAAA,2KAAU,EAAC;IAC3B,IAAI,YAAY,WAAW;QACzB,MAAM,IAAI,MAAM;IAClB;IACA,OAAO;AACT;IANgB"}},
    {"offset": {"line": 227, "column": 0}, "map": {"version":3,"sources":["file:///mnt/g/files/documents/webdev/algo-app/src/hooks/useAudioCapture.ts"],"sourcesContent":["\"use client\";\n\nimport { useState, useRef, useCallback, useEffect } from \"react\";\n\ninterface AudioCaptureState {\n  isCapturing: boolean;\n  isRecording: boolean;\n  isPaused: boolean;\n  audioLevel: number;\n  duration: number;\n  error: string | null;\n}\n\ninterface UseAudioCaptureOptions {\n  onAudioData?: (data: Float32Array) => void;\n}\n\nexport function useAudioCapture(options: UseAudioCaptureOptions = {}) {\n  const [state, setState] = useState<AudioCaptureState>({\n    isCapturing: false,\n    isRecording: false,\n    isPaused: false,\n    audioLevel: 0,\n    duration: 0,\n    error: null,\n  });\n\n  const audioContextRef = useRef<AudioContext | null>(null);\n  const mediaStreamRef = useRef<MediaStream | null>(null);\n  const sourceNodeRef = useRef<MediaStreamAudioSourceNode | null>(null);\n  const gainNodeRef = useRef<GainNode | null>(null);\n  const analyserNodeRef = useRef<AnalyserNode | null>(null);\n  const mediaRecorderRef = useRef<MediaRecorder | null>(null);\n  const recordedChunksRef = useRef<Blob[]>([]);\n  const animationFrameRef = useRef<number | null>(null);\n  const startTimeRef = useRef<number>(0);\n  const durationIntervalRef = useRef<NodeJS.Timeout | null>(null);\n  const isCapturingRef = useRef<boolean>(false);\n\n  // Clean up on unmount\n  useEffect(() => {\n    return () => {\n      stopCapture();\n    };\n  }, []);\n\n  const updateAudioLevel = useCallback(() => {\n    if (!analyserNodeRef.current || !isCapturingRef.current) {\n      return;\n    }\n\n    const analyser = analyserNodeRef.current;\n\n    // Try both frequency and time domain data\n    const freqData = new Uint8Array(analyser.frequencyBinCount);\n    analyser.getByteFrequencyData(freqData);\n\n    const timeData = new Uint8Array(analyser.fftSize);\n    analyser.getByteTimeDomainData(timeData);\n\n    // Calculate average from frequency data\n    const freqAverage = freqData.reduce((a, b) => a + b, 0) / freqData.length;\n    const freqLevel = Math.round((freqAverage / 255) * 100);\n\n    // Calculate RMS from time domain data\n    let sum = 0;\n    for (let i = 0; i < timeData.length; i++) {\n      const normalized = (timeData[i] - 128) / 128;\n      sum += normalized * normalized;\n    }\n    const rms = Math.sqrt(sum / timeData.length);\n    const timeLevel = Math.round(rms * 100);\n\n    // Use the higher of the two\n    const level = Math.max(freqLevel, timeLevel);\n\n    // Optional: Uncomment for debugging\n    // if (Math.random() < 0.01) {\n    //   console.log(\"Audio level:\", level);\n    // }\n\n    setState((prev) => ({ ...prev, audioLevel: level }));\n\n    animationFrameRef.current = requestAnimationFrame(updateAudioLevel);\n  }, []); // No dependencies - use refs instead\n\n  const startCapture = useCallback(async (deviceId?: string) => {\n    try {\n      setState((prev) => ({ ...prev, error: null }));\n\n      // Request microphone/line-in access\n      const audioConstraints: MediaTrackConstraints = {\n        echoCancellation: false,\n        noiseSuppression: false,\n        autoGainControl: false,\n      };\n\n      // If a specific device is requested, use it\n      if (deviceId) {\n        audioConstraints.deviceId = { exact: deviceId };\n      }\n\n      const stream = await navigator.mediaDevices.getUserMedia({\n        audio: audioConstraints,\n        video: false,\n      });\n\n      // DEBUG: Log information about the captured stream\n      const audioTracks = stream.getAudioTracks();\n      if (audioTracks.length > 0) {\n        const track = audioTracks[0];\n        console.log('[AudioCapture] ðŸŽ¤ Started monitoring:');\n        console.log('  - Device Label:', track.label);\n        console.log('  - Device ID:', track.getSettings().deviceId);\n        console.log('  - Sample Rate:', track.getSettings().sampleRate);\n        console.log('  - Channel Count:', track.getSettings().channelCount);\n      }\n\n      mediaStreamRef.current = stream;\n\n      // Create audio context\n      const audioContext = new AudioContext();\n      audioContextRef.current = audioContext;\n\n      // Create nodes\n      const sourceNode = audioContext.createMediaStreamSource(stream);\n      sourceNodeRef.current = sourceNode;\n\n      const gainNode = audioContext.createGain();\n      gainNodeRef.current = gainNode;\n\n      const analyserNode = audioContext.createAnalyser();\n      analyserNode.fftSize = 256;\n      analyserNodeRef.current = analyserNode;\n\n      // Connect nodes: source -> gain -> analyser\n      sourceNode.connect(gainNode);\n      gainNode.connect(analyserNode);\n\n      // Set capturing flag BEFORE starting animation frame\n      isCapturingRef.current = true;\n      setState((prev) => ({ ...prev, isCapturing: true }));\n\n      // Start level monitoring\n      animationFrameRef.current = requestAnimationFrame(updateAudioLevel);\n    } catch (error) {\n      const errorMessage =\n        error instanceof Error ? error.message : \"Failed to access audio input\";\n      setState((prev) => ({ ...prev, error: errorMessage }));\n      console.error(\"Audio capture error:\", error);\n    }\n  }, [updateAudioLevel]);\n\n  const stopCapture = useCallback(() => {\n    // Stop capturing flag first\n    isCapturingRef.current = false;\n\n    // Stop animation frame\n    if (animationFrameRef.current) {\n      cancelAnimationFrame(animationFrameRef.current);\n      animationFrameRef.current = null;\n    }\n\n    // Stop duration interval\n    if (durationIntervalRef.current) {\n      clearInterval(durationIntervalRef.current);\n      durationIntervalRef.current = null;\n    }\n\n    // Stop media recorder\n    if (mediaRecorderRef.current && mediaRecorderRef.current.state !== \"inactive\") {\n      mediaRecorderRef.current.stop();\n    }\n    mediaRecorderRef.current = null;\n\n    // Stop all tracks\n    if (mediaStreamRef.current) {\n      mediaStreamRef.current.getTracks().forEach((track) => track.stop());\n      mediaStreamRef.current = null;\n    }\n\n    // Close audio context\n    if (audioContextRef.current) {\n      audioContextRef.current.close();\n      audioContextRef.current = null;\n    }\n\n    // Clear refs\n    sourceNodeRef.current = null;\n    gainNodeRef.current = null;\n    analyserNodeRef.current = null;\n    recordedChunksRef.current = [];\n\n    setState({\n      isCapturing: false,\n      isRecording: false,\n      isPaused: false,\n      audioLevel: 0,\n      duration: 0,\n      error: null,\n    });\n  }, []);\n\n  const setVolume = useCallback((volume: number) => {\n    if (gainNodeRef.current) {\n      // Convert 0-100 to 0-2 (allowing boost up to 2x)\n      gainNodeRef.current.gain.value = volume / 50;\n    }\n  }, []);\n\n  const startRecording = useCallback(() => {\n    if (!mediaStreamRef.current || state.isRecording) return;\n\n    recordedChunksRef.current = [];\n\n    const mediaRecorder = new MediaRecorder(mediaStreamRef.current, {\n      mimeType: \"audio/webm;codecs=opus\",\n    });\n\n    mediaRecorder.ondataavailable = (event) => {\n      if (event.data.size > 0) {\n        recordedChunksRef.current.push(event.data);\n      }\n    };\n\n    mediaRecorderRef.current = mediaRecorder;\n    mediaRecorder.start(100); // Collect data every 100ms\n\n    startTimeRef.current = Date.now();\n    durationIntervalRef.current = setInterval(() => {\n      const elapsed = Math.floor((Date.now() - startTimeRef.current) / 1000);\n      setState((prev) => ({ ...prev, duration: elapsed }));\n    }, 1000);\n\n    setState((prev) => ({ ...prev, isRecording: true, duration: 0 }));\n  }, [state.isRecording]);\n\n  const stopRecording = useCallback(async (): Promise<Blob | null> => {\n    return new Promise((resolve) => {\n      if (!mediaRecorderRef.current || !state.isRecording) {\n        resolve(null);\n        return;\n      }\n\n      if (durationIntervalRef.current) {\n        clearInterval(durationIntervalRef.current);\n        durationIntervalRef.current = null;\n      }\n\n      const mediaRecorder = mediaRecorderRef.current;\n\n      mediaRecorder.onstop = () => {\n        const blob = new Blob(recordedChunksRef.current, { type: \"audio/webm\" });\n        recordedChunksRef.current = [];\n        setState((prev) => ({ ...prev, isRecording: false }));\n        resolve(blob);\n      };\n\n      mediaRecorder.stop();\n    });\n  }, [state.isRecording]);\n\n  const pauseRecording = useCallback(() => {\n    if (mediaRecorderRef.current && state.isRecording && !state.isPaused) {\n      mediaRecorderRef.current.pause();\n      if (durationIntervalRef.current) {\n        clearInterval(durationIntervalRef.current);\n      }\n      setState((prev) => ({ ...prev, isPaused: true }));\n    }\n  }, [state.isRecording, state.isPaused]);\n\n  const resumeRecording = useCallback(() => {\n    if (mediaRecorderRef.current && state.isRecording && state.isPaused) {\n      mediaRecorderRef.current.resume();\n      durationIntervalRef.current = setInterval(() => {\n        const elapsed = Math.floor((Date.now() - startTimeRef.current) / 1000);\n        setState((prev) => ({ ...prev, duration: elapsed }));\n      }, 1000);\n      setState((prev) => ({ ...prev, isPaused: false }));\n    }\n  }, [state.isRecording, state.isPaused]);\n\n  const getInputDevices = useCallback(async () => {\n    try {\n      const devices = await navigator.mediaDevices.enumerateDevices();\n      return devices.filter((device) => device.kind === \"audioinput\");\n    } catch (error) {\n      console.error(\"Failed to enumerate devices:\", error);\n      return [];\n    }\n  }, []);\n\n  return {\n    ...state,\n    startCapture,\n    stopCapture,\n    startRecording,\n    stopRecording,\n    pauseRecording,\n    resumeRecording,\n    setVolume,\n    getInputDevices,\n    mediaStream: mediaStreamRef.current, // Expose the monitoring stream\n  };\n}\n"],"names":[],"mappings":";;;;AAEA;;AAFA;;AAiBO,SAAS,gBAAgB,UAAkC,CAAC,CAAC;;IAClE,MAAM,CAAC,OAAO,SAAS,GAAG,IAAA,yKAAQ,EAAoB;QACpD,aAAa;QACb,aAAa;QACb,UAAU;QACV,YAAY;QACZ,UAAU;QACV,OAAO;IACT;IAEA,MAAM,kBAAkB,IAAA,uKAAM,EAAsB;IACpD,MAAM,iBAAiB,IAAA,uKAAM,EAAqB;IAClD,MAAM,gBAAgB,IAAA,uKAAM,EAAoC;IAChE,MAAM,cAAc,IAAA,uKAAM,EAAkB;IAC5C,MAAM,kBAAkB,IAAA,uKAAM,EAAsB;IACpD,MAAM,mBAAmB,IAAA,uKAAM,EAAuB;IACtD,MAAM,oBAAoB,IAAA,uKAAM,EAAS,EAAE;IAC3C,MAAM,oBAAoB,IAAA,uKAAM,EAAgB;IAChD,MAAM,eAAe,IAAA,uKAAM,EAAS;IACpC,MAAM,sBAAsB,IAAA,uKAAM,EAAwB;IAC1D,MAAM,iBAAiB,IAAA,uKAAM,EAAU;IAEvC,sBAAsB;IACtB,IAAA,0KAAS;qCAAC;YACR;6CAAO;oBACL;gBACF;;QACF;oCAAG,EAAE;IAEL,MAAM,mBAAmB,IAAA,4KAAW;yDAAC;YACnC,IAAI,CAAC,gBAAgB,OAAO,IAAI,CAAC,eAAe,OAAO,EAAE;gBACvD;YACF;YAEA,MAAM,WAAW,gBAAgB,OAAO;YAExC,0CAA0C;YAC1C,MAAM,WAAW,IAAI,WAAW,SAAS,iBAAiB;YAC1D,SAAS,oBAAoB,CAAC;YAE9B,MAAM,WAAW,IAAI,WAAW,SAAS,OAAO;YAChD,SAAS,qBAAqB,CAAC;YAE/B,wCAAwC;YACxC,MAAM,cAAc,SAAS,MAAM;iEAAC,CAAC,GAAG,IAAM,IAAI;gEAAG,KAAK,SAAS,MAAM;YACzE,MAAM,YAAY,KAAK,KAAK,CAAC,AAAC,cAAc,MAAO;YAEnD,sCAAsC;YACtC,IAAI,MAAM;YACV,IAAK,IAAI,IAAI,GAAG,IAAI,SAAS,MAAM,EAAE,IAAK;gBACxC,MAAM,aAAa,CAAC,QAAQ,CAAC,EAAE,GAAG,GAAG,IAAI;gBACzC,OAAO,aAAa;YACtB;YACA,MAAM,MAAM,KAAK,IAAI,CAAC,MAAM,SAAS,MAAM;YAC3C,MAAM,YAAY,KAAK,KAAK,CAAC,MAAM;YAEnC,4BAA4B;YAC5B,MAAM,QAAQ,KAAK,GAAG,CAAC,WAAW;YAElC,oCAAoC;YACpC,8BAA8B;YAC9B,wCAAwC;YACxC,IAAI;YAEJ;iEAAS,CAAC,OAAS,CAAC;wBAAE,GAAG,IAAI;wBAAE,YAAY;oBAAM,CAAC;;YAElD,kBAAkB,OAAO,GAAG,sBAAsB;QACpD;wDAAG,EAAE,GAAG,qCAAqC;IAE7C,MAAM,eAAe,IAAA,4KAAW;qDAAC,OAAO;YACtC,IAAI;gBACF;iEAAS,CAAC,OAAS,CAAC;4BAAE,GAAG,IAAI;4BAAE,OAAO;wBAAK,CAAC;;gBAE5C,oCAAoC;gBACpC,MAAM,mBAA0C;oBAC9C,kBAAkB;oBAClB,kBAAkB;oBAClB,iBAAiB;gBACnB;gBAEA,4CAA4C;gBAC5C,IAAI,UAAU;oBACZ,iBAAiB,QAAQ,GAAG;wBAAE,OAAO;oBAAS;gBAChD;gBAEA,MAAM,SAAS,MAAM,UAAU,YAAY,CAAC,YAAY,CAAC;oBACvD,OAAO;oBACP,OAAO;gBACT;gBAEA,mDAAmD;gBACnD,MAAM,cAAc,OAAO,cAAc;gBACzC,IAAI,YAAY,MAAM,GAAG,GAAG;oBAC1B,MAAM,QAAQ,WAAW,CAAC,EAAE;oBAC5B,QAAQ,GAAG,CAAC;oBACZ,QAAQ,GAAG,CAAC,qBAAqB,MAAM,KAAK;oBAC5C,QAAQ,GAAG,CAAC,kBAAkB,MAAM,WAAW,GAAG,QAAQ;oBAC1D,QAAQ,GAAG,CAAC,oBAAoB,MAAM,WAAW,GAAG,UAAU;oBAC9D,QAAQ,GAAG,CAAC,sBAAsB,MAAM,WAAW,GAAG,YAAY;gBACpE;gBAEA,eAAe,OAAO,GAAG;gBAEzB,uBAAuB;gBACvB,MAAM,eAAe,IAAI;gBACzB,gBAAgB,OAAO,GAAG;gBAE1B,eAAe;gBACf,MAAM,aAAa,aAAa,uBAAuB,CAAC;gBACxD,cAAc,OAAO,GAAG;gBAExB,MAAM,WAAW,aAAa,UAAU;gBACxC,YAAY,OAAO,GAAG;gBAEtB,MAAM,eAAe,aAAa,cAAc;gBAChD,aAAa,OAAO,GAAG;gBACvB,gBAAgB,OAAO,GAAG;gBAE1B,4CAA4C;gBAC5C,WAAW,OAAO,CAAC;gBACnB,SAAS,OAAO,CAAC;gBAEjB,qDAAqD;gBACrD,eAAe,OAAO,GAAG;gBACzB;iEAAS,CAAC,OAAS,CAAC;4BAAE,GAAG,IAAI;4BAAE,aAAa;wBAAK,CAAC;;gBAElD,yBAAyB;gBACzB,kBAAkB,OAAO,GAAG,sBAAsB;YACpD,EAAE,OAAO,OAAO;gBACd,MAAM,eACJ,iBAAiB,QAAQ,MAAM,OAAO,GAAG;gBAC3C;iEAAS,CAAC,OAAS,CAAC;4BAAE,GAAG,IAAI;4BAAE,OAAO;wBAAa,CAAC;;gBACpD,QAAQ,KAAK,CAAC,wBAAwB;YACxC;QACF;oDAAG;QAAC;KAAiB;IAErB,MAAM,cAAc,IAAA,4KAAW;oDAAC;YAC9B,4BAA4B;YAC5B,eAAe,OAAO,GAAG;YAEzB,uBAAuB;YACvB,IAAI,kBAAkB,OAAO,EAAE;gBAC7B,qBAAqB,kBAAkB,OAAO;gBAC9C,kBAAkB,OAAO,GAAG;YAC9B;YAEA,yBAAyB;YACzB,IAAI,oBAAoB,OAAO,EAAE;gBAC/B,cAAc,oBAAoB,OAAO;gBACzC,oBAAoB,OAAO,GAAG;YAChC;YAEA,sBAAsB;YACtB,IAAI,iBAAiB,OAAO,IAAI,iBAAiB,OAAO,CAAC,KAAK,KAAK,YAAY;gBAC7E,iBAAiB,OAAO,CAAC,IAAI;YAC/B;YACA,iBAAiB,OAAO,GAAG;YAE3B,kBAAkB;YAClB,IAAI,eAAe,OAAO,EAAE;gBAC1B,eAAe,OAAO,CAAC,SAAS,GAAG,OAAO;gEAAC,CAAC,QAAU,MAAM,IAAI;;gBAChE,eAAe,OAAO,GAAG;YAC3B;YAEA,sBAAsB;YACtB,IAAI,gBAAgB,OAAO,EAAE;gBAC3B,gBAAgB,OAAO,CAAC,KAAK;gBAC7B,gBAAgB,OAAO,GAAG;YAC5B;YAEA,aAAa;YACb,cAAc,OAAO,GAAG;YACxB,YAAY,OAAO,GAAG;YACtB,gBAAgB,OAAO,GAAG;YAC1B,kBAAkB,OAAO,GAAG,EAAE;YAE9B,SAAS;gBACP,aAAa;gBACb,aAAa;gBACb,UAAU;gBACV,YAAY;gBACZ,UAAU;gBACV,OAAO;YACT;QACF;mDAAG,EAAE;IAEL,MAAM,YAAY,IAAA,4KAAW;kDAAC,CAAC;YAC7B,IAAI,YAAY,OAAO,EAAE;gBACvB,iDAAiD;gBACjD,YAAY,OAAO,CAAC,IAAI,CAAC,KAAK,GAAG,SAAS;YAC5C;QACF;iDAAG,EAAE;IAEL,MAAM,iBAAiB,IAAA,4KAAW;uDAAC;YACjC,IAAI,CAAC,eAAe,OAAO,IAAI,MAAM,WAAW,EAAE;YAElD,kBAAkB,OAAO,GAAG,EAAE;YAE9B,MAAM,gBAAgB,IAAI,cAAc,eAAe,OAAO,EAAE;gBAC9D,UAAU;YACZ;YAEA,cAAc,eAAe;+DAAG,CAAC;oBAC/B,IAAI,MAAM,IAAI,CAAC,IAAI,GAAG,GAAG;wBACvB,kBAAkB,OAAO,CAAC,IAAI,CAAC,MAAM,IAAI;oBAC3C;gBACF;;YAEA,iBAAiB,OAAO,GAAG;YAC3B,cAAc,KAAK,CAAC,MAAM,2BAA2B;YAErD,aAAa,OAAO,GAAG,KAAK,GAAG;YAC/B,oBAAoB,OAAO,GAAG;+DAAY;oBACxC,MAAM,UAAU,KAAK,KAAK,CAAC,CAAC,KAAK,GAAG,KAAK,aAAa,OAAO,IAAI;oBACjE;uEAAS,CAAC,OAAS,CAAC;gCAAE,GAAG,IAAI;gCAAE,UAAU;4BAAQ,CAAC;;gBACpD;8DAAG;YAEH;+DAAS,CAAC,OAAS,CAAC;wBAAE,GAAG,IAAI;wBAAE,aAAa;wBAAM,UAAU;oBAAE,CAAC;;QACjE;sDAAG;QAAC,MAAM,WAAW;KAAC;IAEtB,MAAM,gBAAgB,IAAA,4KAAW;sDAAC;YAChC,OAAO,IAAI;8DAAQ,CAAC;oBAClB,IAAI,CAAC,iBAAiB,OAAO,IAAI,CAAC,MAAM,WAAW,EAAE;wBACnD,QAAQ;wBACR;oBACF;oBAEA,IAAI,oBAAoB,OAAO,EAAE;wBAC/B,cAAc,oBAAoB,OAAO;wBACzC,oBAAoB,OAAO,GAAG;oBAChC;oBAEA,MAAM,gBAAgB,iBAAiB,OAAO;oBAE9C,cAAc,MAAM;sEAAG;4BACrB,MAAM,OAAO,IAAI,KAAK,kBAAkB,OAAO,EAAE;gCAAE,MAAM;4BAAa;4BACtE,kBAAkB,OAAO,GAAG,EAAE;4BAC9B;8EAAS,CAAC,OAAS,CAAC;wCAAE,GAAG,IAAI;wCAAE,aAAa;oCAAM,CAAC;;4BACnD,QAAQ;wBACV;;oBAEA,cAAc,IAAI;gBACpB;;QACF;qDAAG;QAAC,MAAM,WAAW;KAAC;IAEtB,MAAM,iBAAiB,IAAA,4KAAW;uDAAC;YACjC,IAAI,iBAAiB,OAAO,IAAI,MAAM,WAAW,IAAI,CAAC,MAAM,QAAQ,EAAE;gBACpE,iBAAiB,OAAO,CAAC,KAAK;gBAC9B,IAAI,oBAAoB,OAAO,EAAE;oBAC/B,cAAc,oBAAoB,OAAO;gBAC3C;gBACA;mEAAS,CAAC,OAAS,CAAC;4BAAE,GAAG,IAAI;4BAAE,UAAU;wBAAK,CAAC;;YACjD;QACF;sDAAG;QAAC,MAAM,WAAW;QAAE,MAAM,QAAQ;KAAC;IAEtC,MAAM,kBAAkB,IAAA,4KAAW;wDAAC;YAClC,IAAI,iBAAiB,OAAO,IAAI,MAAM,WAAW,IAAI,MAAM,QAAQ,EAAE;gBACnE,iBAAiB,OAAO,CAAC,MAAM;gBAC/B,oBAAoB,OAAO,GAAG;oEAAY;wBACxC,MAAM,UAAU,KAAK,KAAK,CAAC,CAAC,KAAK,GAAG,KAAK,aAAa,OAAO,IAAI;wBACjE;4EAAS,CAAC,OAAS,CAAC;oCAAE,GAAG,IAAI;oCAAE,UAAU;gCAAQ,CAAC;;oBACpD;mEAAG;gBACH;oEAAS,CAAC,OAAS,CAAC;4BAAE,GAAG,IAAI;4BAAE,UAAU;wBAAM,CAAC;;YAClD;QACF;uDAAG;QAAC,MAAM,WAAW;QAAE,MAAM,QAAQ;KAAC;IAEtC,MAAM,kBAAkB,IAAA,4KAAW;wDAAC;YAClC,IAAI;gBACF,MAAM,UAAU,MAAM,UAAU,YAAY,CAAC,gBAAgB;gBAC7D,OAAO,QAAQ,MAAM;oEAAC,CAAC,SAAW,OAAO,IAAI,KAAK;;YACpD,EAAE,OAAO,OAAO;gBACd,QAAQ,KAAK,CAAC,gCAAgC;gBAC9C,OAAO,EAAE;YACX;QACF;uDAAG,EAAE;IAEL,OAAO;QACL,GAAG,KAAK;QACR;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA,aAAa,eAAe,OAAO;IACrC;AACF;GAhSgB"}},
    {"offset": {"line": 587, "column": 0}, "map": {"version":3,"sources":["file:///mnt/g/files/documents/webdev/algo-app/src/lib/settings.ts"],"sourcesContent":["/**\n * Utility functions for getting app settings from localStorage\n */\n\n/**\n * Get the configured idle volume level for speakers\n * @returns The idle volume in dB (default: -45)\n */\nexport function getIdleVolume(): number {\n  if (typeof window === \"undefined\") {\n    return -45; // Server-side default\n  }\n\n  const saved = localStorage.getItem(\"algoapp-idle-volume\");\n  if (saved) {\n    const parsed = parseInt(saved);\n    // Validate range\n    if (parsed >= -60 && parsed <= 0) {\n      return parsed;\n    }\n  }\n\n  return -45; // Default\n}\n\n/**\n * Get the idle volume as a string with \"dB\" suffix (for Algo API)\n * @returns The idle volume as a string like \"-45dB\"\n */\nexport function getIdleVolumeString(): string {\n  return `${getIdleVolume()}dB`;\n}\n\n/**\n * Get the default volume for new distributions\n * @returns The default volume (0-100)\n */\nexport function getDefaultVolume(): number {\n  if (typeof window === \"undefined\") {\n    return 50; // Server-side default\n  }\n\n  const saved = localStorage.getItem(\"algoapp-default-volume\");\n  if (saved) {\n    const parsed = parseInt(saved);\n    // Validate range\n    if (parsed >= 0 && parsed <= 100) {\n      return parsed;\n    }\n  }\n\n  return 50; // Default\n}\n\n/**\n * Get whether to always keep paging device in transmitter mode\n * @returns true if paging device should always be in mode 1, false to toggle based on audio\n */\nexport function getAlwaysKeepPagingOn(): boolean {\n  if (typeof window === \"undefined\") {\n    return false; // Server-side default\n  }\n\n  const saved = localStorage.getItem(\"algoapp-always-keep-paging-on\");\n  return saved === \"true\";\n}\n"],"names":[],"mappings":"AAAA;;CAEC,GAED;;;CAGC;;;;;;;;;;AACM,SAAS;IACd;;IAIA,MAAM,QAAQ,aAAa,OAAO,CAAC;IACnC,IAAI,OAAO;QACT,MAAM,SAAS,SAAS;QACxB,iBAAiB;QACjB,IAAI,UAAU,CAAC,MAAM,UAAU,GAAG;YAChC,OAAO;QACT;IACF;IAEA,OAAO,CAAC,IAAI,UAAU;AACxB;AAMO,SAAS;IACd,OAAO,GAAG,gBAAgB,EAAE,CAAC;AAC/B;AAMO,SAAS;IACd;;IAIA,MAAM,QAAQ,aAAa,OAAO,CAAC;IACnC,IAAI,OAAO;QACT,MAAM,SAAS,SAAS;QACxB,iBAAiB;QACjB,IAAI,UAAU,KAAK,UAAU,KAAK;YAChC,OAAO;QACT;IACF;IAEA,OAAO,IAAI,UAAU;AACvB;AAMO,SAAS;IACd;;IAIA,MAAM,QAAQ,aAAa,OAAO,CAAC;IACnC,OAAO,UAAU;AACnB"}},
    {"offset": {"line": 644, "column": 0}, "map": {"version":3,"sources":["file:///mnt/g/files/documents/webdev/algo-app/src/contexts/audio-monitoring-context.tsx"],"sourcesContent":["\"use client\";\n\nimport { createContext, useContext, useState, useRef, useCallback, useEffect } from \"react\";\nimport { useAudioCapture } from \"@/hooks/useAudioCapture\";\nimport type { AlgoDevice, PoEDevice } from \"@/lib/algo/types\";\nimport { storage } from \"@/lib/firebase/config\";\nimport { ref as storageRef, uploadBytes, getDownloadURL } from \"firebase/storage\";\nimport { useAuth } from \"@/contexts/auth-context\";\nimport { getIdleVolumeString, getAlwaysKeepPagingOn } from \"@/lib/settings\";\n\n// Debug mode - set to false for production to reduce console noise\nconst DEBUG_MODE = process.env.NODE_ENV === 'development';\n\n// Debug logging helper - only logs in development\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nconst debugLog = (...args: any[]) => {\n  if (DEBUG_MODE) {\n    console.log(...args);\n  }\n};\n\n// Web Worker for MP3 encoding\nlet mp3Worker: Worker | null = null;\n\nexport interface AudioLogEntry {\n  timestamp: string;\n  type: \"audio_detected\" | \"audio_silent\" | \"speakers_enabled\" | \"speakers_disabled\" | \"volume_change\";\n  audioLevel?: number;\n  audioThreshold?: number;\n  speakersEnabled?: boolean;\n  volume?: number;\n  message: string;\n  recordingUrl?: string; // URL to recorded audio clip\n}\n\n// Speaker connectivity status\nexport interface SpeakerStatus {\n  speakerId: string;\n  speakerName: string;\n  ipAddress: string;\n  isOnline: boolean;\n  lastChecked: Date;\n  errorMessage?: string;\n}\n\ninterface AudioMonitoringContextType {\n  // Audio capture state\n  isCapturing: boolean;\n  audioLevel: number;\n  selectedInputDevice: string;\n  volume: number;\n  targetVolume: number;\n  audioThreshold: number;\n\n  // Speaker state\n  audioDetected: boolean;\n  speakersEnabled: boolean;\n\n  // Volume mode\n  useGlobalVolume: boolean;\n  setUseGlobalVolume: (useGlobal: boolean) => void;\n\n  // Ramp settings\n  rampEnabled: boolean;\n  rampDuration: number;\n  dayNightMode: boolean;\n  dayStartHour: number;\n  dayEndHour: number;\n  nightRampDuration: number;\n  sustainDuration: number;\n  disableDelay: number;\n  setRampEnabled: (enabled: boolean) => void;\n  setRampDuration: (duration: number) => void;\n  setDayNightMode: (enabled: boolean) => void;\n  setDayStartHour: (hour: number) => void;\n  setDayEndHour: (hour: number) => void;\n  setNightRampDuration: (duration: number) => void;\n  setSustainDuration: (duration: number) => void;\n  setDisableDelay: (delay: number) => void;\n\n  // Device selection\n  selectedDevices: string[];\n  setSelectedDevices: (devices: string[]) => void;\n\n  // Actions\n  startMonitoring: (inputDevice?: string) => void;\n  stopMonitoring: () => void;\n  setInputDevice: (deviceId: string) => void;\n  setVolume: (volume: number) => void;\n  setTargetVolume: (volume: number) => void;\n  setAudioThreshold: (threshold: number) => void;\n\n  // For controlling speakers\n  devices: AlgoDevice[];\n  setDevices: (devices: AlgoDevice[]) => void;\n\n  // For controlling PoE devices (lights, etc.)\n  poeDevices: PoEDevice[];\n  setPoeDevices: (devices: PoEDevice[]) => void;\n\n  // Logging\n  logs: AudioLogEntry[];\n  clearLogs: () => void;\n  exportLogs: () => string;\n  loggingEnabled: boolean;\n  setLoggingEnabled: (enabled: boolean) => void;\n\n  // Recording\n  recordingEnabled: boolean;\n  setRecordingEnabled: (enabled: boolean) => void;\n\n  // Emergency Controls\n  emergencyKillAll: () => Promise<void>;\n  emergencyEnableAll: () => Promise<void>;\n  controlSingleSpeaker: (speakerId: string, enable: boolean) => Promise<void>;\n\n  // Speaker Status Tracking\n  speakerStatuses: SpeakerStatus[];\n  checkSpeakerConnectivity: () => Promise<void>;\n}\n\nconst AudioMonitoringContext = createContext<AudioMonitoringContextType | null>(null);\n\n// Helper function to convert audio blob to MP3 using Web Worker\nasync function convertToMp3(audioBlob: Blob): Promise<Blob> {\n  console.log('[MP3 Convert] Starting conversion, blob size:', audioBlob.size, 'type:', audioBlob.type);\n\n  // Decode the audio blob to an AudioBuffer\n  const arrayBuffer = await audioBlob.arrayBuffer();\n  console.log('[MP3 Convert] ArrayBuffer size:', arrayBuffer.byteLength);\n\n  const audioContext = new AudioContext();\n  console.log('[MP3 Convert] AudioContext created, decoding...');\n\n  const audioBuffer = await audioContext.decodeAudioData(arrayBuffer);\n  console.log('[MP3 Convert] Decoded - channels:', audioBuffer.numberOfChannels, 'sampleRate:', audioBuffer.sampleRate, 'duration:', audioBuffer.duration);\n\n  // Get audio data as Float32Arrays\n  const numberOfChannels = audioBuffer.numberOfChannels;\n  const sampleRate = audioBuffer.sampleRate;\n\n  const audioData: Float32Array[] = [];\n  for (let i = 0; i < numberOfChannels; i++) {\n    audioData.push(audioBuffer.getChannelData(i));\n  }\n\n  // Close the audio context\n  await audioContext.close();\n\n  // Initialize Web Worker if not already done\n  if (!mp3Worker) {\n    console.log('[MP3 Convert] Creating Web Worker...');\n    mp3Worker = new Worker('/mp3-encoder-worker.js');\n  }\n\n  // Encode using Web Worker\n  return new Promise((resolve, reject) => {\n    if (!mp3Worker) {\n      reject(new Error('Web Worker not available'));\n      return;\n    }\n\n    const timeoutId = setTimeout(() => {\n      reject(new Error('MP3 encoding timeout'));\n    }, 30000); // 30 second timeout\n\n    mp3Worker.onmessage = (e) => {\n      clearTimeout(timeoutId);\n\n      if (e.data.error) {\n        console.error('[MP3 Convert] Worker error:', e.data.error);\n        reject(new Error(e.data.error));\n        return;\n      }\n\n      if (e.data.progress !== undefined) {\n        // Progress update - ignore for now\n        return;\n      }\n\n      if (e.data.success && e.data.mp3Data) {\n        console.log('[MP3 Convert] Worker success, output size:', e.data.mp3Data.byteLength);\n        const mp3Blob = new Blob([e.data.mp3Data], { type: 'audio/mp3' });\n        resolve(mp3Blob);\n      }\n    };\n\n    mp3Worker.onerror = (error) => {\n      clearTimeout(timeoutId);\n      console.error('[MP3 Convert] Worker error:', error);\n      reject(new Error('MP3 Worker error: ' + error.message));\n    };\n\n    // Send audio data to worker\n    console.log('[MP3 Convert] Sending to worker...');\n    mp3Worker.postMessage({\n      cmd: 'encode',\n      audioData: audioData,\n      sampleRate: sampleRate,\n      bitRate: 128\n    });\n  });\n}\n\n// LocalStorage keys\nconst STORAGE_KEYS = {\n  IS_MONITORING: 'algo_live_is_monitoring',\n  SELECTED_DEVICES: 'algo_live_selected_devices',\n  SELECTED_INPUT: 'algo_live_selected_input',\n  TARGET_VOLUME: 'algo_live_target_volume',\n  INPUT_GAIN: 'algo_live_input_gain',\n  AUDIO_THRESHOLD: 'algo_live_audio_threshold',\n  USE_GLOBAL_VOLUME: 'algo_use_global_volume',\n  RAMP_ENABLED: 'algo_live_ramp_enabled',\n  RAMP_DURATION: 'algo_live_ramp_duration',\n  DAY_NIGHT_MODE: 'algo_live_day_night_mode',\n  DAY_START_HOUR: 'algo_live_day_start_hour',\n  DAY_END_HOUR: 'algo_live_day_end_hour',\n  NIGHT_RAMP_DURATION: 'algo_live_night_ramp_duration',\n  SUSTAIN_DURATION: 'algo_live_sustain_duration',\n  DISABLE_DELAY: 'algo_live_disable_delay',\n  LOGGING_ENABLED: 'algo_live_logging_enabled',\n  RECORDING_ENABLED: 'algo_live_recording_enabled',\n};\n\nexport function AudioMonitoringProvider({ children }: { children: React.ReactNode }) {\n  const { user } = useAuth();\n\n  const [selectedInputDevice, setSelectedInputDeviceState] = useState<string>(\"\");\n  const [volume, setVolumeState] = useState(50);\n  const [targetVolume, setTargetVolumeState] = useState(100);\n  const [audioThreshold, setAudioThresholdState] = useState(5); // 5% default\n  const [selectedDevices, setSelectedDevicesState] = useState<string[]>([]);\n  const [devices, setDevices] = useState<AlgoDevice[]>([]);\n  const [poeDevices, setPoeDevices] = useState<PoEDevice[]>([]);\n  const [audioDetected, setAudioDetected] = useState(false);\n  const [speakersEnabled, setSpeakersEnabled] = useState(false);\n\n  // Logging\n  const [logs, setLogs] = useState<AudioLogEntry[]>([]);\n  const [loggingEnabled, setLoggingEnabledState] = useState(true); // enabled by default\n  const [recordingEnabled, setRecordingEnabledState] = useState(false); // disabled by default to save storage\n\n  // Volume mode\n  const [useGlobalVolume, setUseGlobalVolumeState] = useState(false);\n\n  // Speaker status tracking\n  const [speakerStatuses, setSpeakerStatuses] = useState<SpeakerStatus[]>([]);\n\n  // Ramp settings\n  const [rampEnabled, setRampEnabledState] = useState(true);\n  const [rampDuration, setRampDurationState] = useState(15); // 15 seconds default\n  const [dayNightMode, setDayNightModeState] = useState(false);\n  const [dayStartHour, setDayStartHourState] = useState(6); // 6 AM\n  const [dayEndHour, setDayEndHourState] = useState(18); // 6 PM\n  const [nightRampDuration, setNightRampDurationState] = useState(10); // 10 seconds for night\n  const [sustainDuration, setSustainDurationState] = useState(1000); // 1 second default (in ms)\n  const [disableDelay, setDisableDelayState] = useState(3000); // 3 seconds default (in ms)\n\n  const audioDetectionTimeoutRef = useRef<NodeJS.Timeout | null>(null);\n  const controllingSpakersRef = useRef<boolean>(false);\n  const volumeRampIntervalRef = useRef<NodeJS.Timeout | null>(null);\n  const currentVolumeRef = useRef<number>(0);\n  const hasRestoredStateRef = useRef<boolean>(false);\n  const isInitializedRef = useRef<boolean>(false);\n  const previousDayModeRef = useRef<boolean | null>(null);\n  const dayNightCheckIntervalRef = useRef<NodeJS.Timeout | null>(null);\n\n  // Sustained audio tracking\n  const sustainedAudioStartRef = useRef<number | null>(null);\n  const sustainCheckIntervalRef = useRef<NodeJS.Timeout | null>(null);\n  const speakersEnabledTimeRef = useRef<number | null>(null);\n\n  // Recording\n  const mediaRecorderRef = useRef<MediaRecorder | null>(null);\n  const recordedChunksRef = useRef<Blob[]>([]);\n  const recordingStartTimeRef = useRef<string | null>(null);\n\n  const {\n    isCapturing,\n    audioLevel,\n    startCapture,\n    stopCapture,\n    setVolume: setGainVolume,\n    mediaStream: monitoringStream,\n  } = useAudioCapture();\n\n  // Helper to add log entry\n  const addLog = useCallback((entry: Omit<AudioLogEntry, \"timestamp\">) => {\n    // Always log to console for debugging\n    const logEntry: AudioLogEntry = {\n      ...entry,\n      timestamp: new Date().toISOString(),\n    };\n    debugLog(`[AudioLog] ${logEntry.message}`, logEntry);\n\n    // Only add to UI logs if logging is enabled\n    if (!loggingEnabled) return;\n\n    setLogs(prev => {\n      const newLogs = [...prev, logEntry];\n      // Keep only last 500 entries to prevent memory issues\n      if (newLogs.length > 500) {\n        return newLogs.slice(-500);\n      }\n      return newLogs;\n    });\n  }, [loggingEnabled]);\n\n  // Get best supported audio mimeType\n  const getBestAudioMimeType = useCallback(() => {\n    const types = [\n      'audio/webm;codecs=opus',\n      'audio/webm',\n      'audio/ogg;codecs=opus',\n      'audio/mp4',\n    ];\n\n    for (const type of types) {\n      if (MediaRecorder.isTypeSupported(type)) {\n        console.log('[Recording] Using mimeType:', type);\n        return type;\n      }\n    }\n\n    console.warn('[Recording] No preferred mimeType supported, using default');\n    return '';\n  }, []);\n\n  // Start recording audio\n  const startRecording = useCallback(async () => {\n    try {\n      if (!recordingEnabled) {\n        debugLog('[Recording] Recording is disabled, skipping');\n        return;\n      }\n\n      if (!user) {\n        console.warn('[Recording] No user authenticated, skipping recording');\n        return;\n      }\n\n      // REUSE the monitoring stream instead of creating a new one\n      if (!monitoringStream) {\n        console.warn('[Recording] No monitoring stream available, skipping recording');\n        return;\n      }\n\n      // DEBUG: Log information about the monitoring stream\n      const audioTracks = monitoringStream.getAudioTracks();\n      if (audioTracks.length > 0) {\n        const track = audioTracks[0];\n        console.log('[Recording] ðŸŽ™ï¸ Recording from monitoring stream:');\n        console.log('  - Device Label:', track.label);\n        console.log('  - Device ID:', track.getSettings().deviceId);\n        console.log('  - Sample Rate:', track.getSettings().sampleRate);\n        console.log('  - Channel Count:', track.getSettings().channelCount);\n      } else {\n        console.warn('[Recording] âš ï¸ No audio tracks in monitoring stream!');\n      }\n\n      // Get best supported mimeType\n      const mimeType = getBestAudioMimeType();\n\n      // Create media recorder with best supported format\n      const options: MediaRecorderOptions = {};\n      if (mimeType) {\n        options.mimeType = mimeType;\n      }\n\n      const mediaRecorder = new MediaRecorder(monitoringStream, options);\n\n      recordedChunksRef.current = [];\n      recordingStartTimeRef.current = new Date().toISOString();\n\n      mediaRecorder.ondataavailable = (event) => {\n        if (event.data.size > 0) {\n          recordedChunksRef.current.push(event.data);\n        }\n      };\n\n      mediaRecorder.start(100); // Collect data every 100ms\n      mediaRecorderRef.current = mediaRecorder;\n\n      debugLog('[Recording] Started recording audio from monitoring stream with mimeType:', mimeType || 'default');\n    } catch (error) {\n      console.error('[Recording] Failed to start recording:', error);\n    }\n  }, [recordingEnabled, user, monitoringStream, getBestAudioMimeType]);\n\n  // Stop recording and upload to Firebase\n  const stopRecordingAndUpload = useCallback(async (): Promise<string | null> => {\n    return new Promise((resolve) => {\n      try {\n        const mediaRecorder = mediaRecorderRef.current;\n        if (!mediaRecorder || !user || !recordingStartTimeRef.current) {\n          resolve(null);\n          return;\n        }\n\n        mediaRecorder.onstop = async () => {\n          try {\n            // Get the mimeType that was actually used\n            const actualMimeType = mediaRecorder.mimeType || 'audio/webm';\n\n            // Create blob from recorded chunks\n            const audioBlob = new Blob(recordedChunksRef.current, { type: actualMimeType });\n\n            if (audioBlob.size === 0) {\n              console.warn('[Recording] No audio data recorded');\n              resolve(null);\n              return;\n            }\n\n            // Determine file extension from mimeType\n            let fileExtension = 'webm';\n            if (actualMimeType.includes('opus')) {\n              fileExtension = 'opus';\n            } else if (actualMimeType.includes('ogg')) {\n              fileExtension = 'ogg';\n            } else if (actualMimeType.includes('mp4')) {\n              fileExtension = 'm4a';\n            }\n\n            console.log(`[Recording] Saving ${audioBlob.size} bytes as ${fileExtension} (${actualMimeType})`);\n\n            // Generate filename with timestamp\n            const timestamp = recordingStartTimeRef.current!.replace(/[:.]/g, '-');\n            const filename = `recording-${timestamp}.${fileExtension}`;\n            const filePath = `audio-recordings/${user.uid}/${filename}`;\n\n            // Upload to Firebase Storage\n            debugLog(`[Recording] Uploading ${fileExtension.toUpperCase()} to ${filePath}`);\n            const fileRef = storageRef(storage, filePath);\n            await uploadBytes(fileRef, audioBlob);\n\n            // Get download URL\n            const downloadUrl = await getDownloadURL(fileRef);\n            debugLog('[Recording] Upload successful:', downloadUrl);\n\n            // Clean up\n            recordedChunksRef.current = [];\n            recordingStartTimeRef.current = null;\n            mediaRecorderRef.current = null;\n\n            // DON'T stop the stream tracks - we're reusing the monitoring stream!\n            // The monitoring stream should only be stopped when stopMonitoring() is called\n\n            resolve(downloadUrl);\n          } catch (error) {\n            console.error('[Recording] Upload failed:', error);\n            resolve(null);\n          }\n        };\n\n        mediaRecorder.stop();\n      } catch (error) {\n        console.error('[Recording] Stop failed:', error);\n        resolve(null);\n      }\n    });\n  }, [user]);\n\n  // Update gain when volume changes\n  useEffect(() => {\n    setGainVolume(volume);\n  }, [volume, setGainVolume]);\n\n  // Initialize and restore state from localStorage on mount\n  useEffect(() => {\n    if (isInitializedRef.current) return;\n    isInitializedRef.current = true;\n\n    debugLog('[AudioMonitoring] Initializing and restoring state...');\n\n    try {\n      const savedDevices = localStorage.getItem(STORAGE_KEYS.SELECTED_DEVICES);\n      const savedInput = localStorage.getItem(STORAGE_KEYS.SELECTED_INPUT);\n      const savedTargetVolume = localStorage.getItem(STORAGE_KEYS.TARGET_VOLUME);\n      const savedInputGain = localStorage.getItem(STORAGE_KEYS.INPUT_GAIN);\n      const savedAudioThreshold = localStorage.getItem(STORAGE_KEYS.AUDIO_THRESHOLD);\n      const savedRampEnabled = localStorage.getItem(STORAGE_KEYS.RAMP_ENABLED);\n      const savedRampDuration = localStorage.getItem(STORAGE_KEYS.RAMP_DURATION);\n      const savedDayNightMode = localStorage.getItem(STORAGE_KEYS.DAY_NIGHT_MODE);\n      const savedDayStartHour = localStorage.getItem(STORAGE_KEYS.DAY_START_HOUR);\n      const savedDayEndHour = localStorage.getItem(STORAGE_KEYS.DAY_END_HOUR);\n      const savedNightRampDuration = localStorage.getItem(STORAGE_KEYS.NIGHT_RAMP_DURATION);\n      const savedSustainDuration = localStorage.getItem(STORAGE_KEYS.SUSTAIN_DURATION);\n      const savedDisableDelay = localStorage.getItem(STORAGE_KEYS.DISABLE_DELAY);\n      const savedLoggingEnabled = localStorage.getItem(STORAGE_KEYS.LOGGING_ENABLED);\n      const savedRecordingEnabled = localStorage.getItem(STORAGE_KEYS.RECORDING_ENABLED);\n      const savedUseGlobalVolume = localStorage.getItem(STORAGE_KEYS.USE_GLOBAL_VOLUME);\n      const wasMonitoring = localStorage.getItem(STORAGE_KEYS.IS_MONITORING) === 'true';\n\n      debugLog('[AudioMonitoring] Saved state:', {\n        devices: savedDevices,\n        input: savedInput,\n        targetVolume: savedTargetVolume,\n        inputGain: savedInputGain,\n        audioThreshold: savedAudioThreshold,\n        rampEnabled: savedRampEnabled,\n        rampDuration: savedRampDuration,\n        dayNightMode: savedDayNightMode,\n        dayStartHour: savedDayStartHour,\n        dayEndHour: savedDayEndHour,\n        nightRampDuration: savedNightRampDuration,\n        wasMonitoring,\n      });\n\n      if (savedDevices && savedDevices !== 'undefined') {\n        try {\n          const deviceIds = JSON.parse(savedDevices);\n          debugLog('[AudioMonitoring] Restoring selected devices:', deviceIds);\n          setSelectedDevicesState(deviceIds);\n        } catch (error) {\n          console.error('[AudioMonitoring] Failed to parse saved devices:', error);\n          setSelectedDevicesState([]);\n        }\n      }\n      if (savedInput) {\n        debugLog('[AudioMonitoring] Restoring input device:', savedInput);\n        setSelectedInputDeviceState(savedInput);\n      }\n      if (savedTargetVolume) {\n        setTargetVolumeState(parseInt(savedTargetVolume));\n      }\n      if (savedInputGain) {\n        setVolumeState(parseInt(savedInputGain));\n      }\n      if (savedAudioThreshold) {\n        setAudioThresholdState(parseInt(savedAudioThreshold));\n      }\n      if (savedRampEnabled !== null) {\n        setRampEnabledState(savedRampEnabled === 'true');\n      }\n      if (savedRampDuration) {\n        setRampDurationState(parseInt(savedRampDuration));\n      }\n      if (savedDayNightMode !== null) {\n        setDayNightModeState(savedDayNightMode === 'true');\n      }\n      if (savedDayStartHour) {\n        setDayStartHourState(parseInt(savedDayStartHour));\n      }\n      if (savedDayEndHour) {\n        setDayEndHourState(parseInt(savedDayEndHour));\n      }\n      if (savedNightRampDuration) {\n        setNightRampDurationState(parseInt(savedNightRampDuration));\n      }\n      if (savedSustainDuration) {\n        setSustainDurationState(parseInt(savedSustainDuration));\n      }\n      if (savedDisableDelay) {\n        setDisableDelayState(parseInt(savedDisableDelay));\n      }\n      if (savedLoggingEnabled !== null) {\n        setLoggingEnabledState(savedLoggingEnabled === 'true');\n      }\n      if (savedRecordingEnabled !== null) {\n        setRecordingEnabledState(savedRecordingEnabled === 'true');\n      }\n      if (savedUseGlobalVolume !== null) {\n        setUseGlobalVolumeState(savedUseGlobalVolume === 'true');\n      }\n\n      // Mark as restored\n      setTimeout(() => {\n        hasRestoredStateRef.current = true;\n        debugLog('[AudioMonitoring] State restoration complete');\n      }, 100);\n\n      // Auto-start monitoring if it was active before\n      if (wasMonitoring) {\n        debugLog('[AudioMonitoring] Auto-resuming monitoring from previous session');\n        setTimeout(() => {\n          startCapture(savedInput || undefined);\n        }, 500);\n      }\n    } catch (error) {\n      console.error('[AudioMonitoring] Failed to restore state:', error);\n      hasRestoredStateRef.current = true;\n    }\n  }, [startCapture]);\n\n  // Persist state changes to localStorage\n  useEffect(() => {\n    if (!hasRestoredStateRef.current) return;\n    debugLog('[AudioMonitoring] Saving selected devices:', selectedDevices);\n    localStorage.setItem(STORAGE_KEYS.SELECTED_DEVICES, JSON.stringify(selectedDevices));\n  }, [selectedDevices]);\n\n  useEffect(() => {\n    if (!hasRestoredStateRef.current) return;\n    debugLog('[AudioMonitoring] Saving input device:', selectedInputDevice);\n    localStorage.setItem(STORAGE_KEYS.SELECTED_INPUT, selectedInputDevice);\n  }, [selectedInputDevice]);\n\n  useEffect(() => {\n    if (!hasRestoredStateRef.current) return;\n    debugLog('[AudioMonitoring] Saving target volume:', targetVolume);\n    localStorage.setItem(STORAGE_KEYS.TARGET_VOLUME, targetVolume.toString());\n  }, [targetVolume]);\n\n  useEffect(() => {\n    if (!hasRestoredStateRef.current) return;\n    debugLog('[AudioMonitoring] Saving input gain:', volume);\n    localStorage.setItem(STORAGE_KEYS.INPUT_GAIN, volume.toString());\n  }, [volume]);\n\n  useEffect(() => {\n    if (!hasRestoredStateRef.current) return;\n    debugLog('[AudioMonitoring] Saving monitoring state:', isCapturing);\n    localStorage.setItem(STORAGE_KEYS.IS_MONITORING, isCapturing.toString());\n  }, [isCapturing]);\n\n  useEffect(() => {\n    if (!hasRestoredStateRef.current) return;\n    debugLog('[AudioMonitoring] Saving audio threshold:', audioThreshold);\n    localStorage.setItem(STORAGE_KEYS.AUDIO_THRESHOLD, audioThreshold.toString());\n  }, [audioThreshold]);\n\n  useEffect(() => {\n    if (!hasRestoredStateRef.current) return;\n    debugLog('[AudioMonitoring] Saving ramp enabled:', rampEnabled);\n    localStorage.setItem(STORAGE_KEYS.RAMP_ENABLED, rampEnabled.toString());\n  }, [rampEnabled]);\n\n  useEffect(() => {\n    if (!hasRestoredStateRef.current) return;\n    debugLog('[AudioMonitoring] Saving ramp duration:', rampDuration);\n    localStorage.setItem(STORAGE_KEYS.RAMP_DURATION, rampDuration.toString());\n  }, [rampDuration]);\n\n  useEffect(() => {\n    if (!hasRestoredStateRef.current) return;\n    debugLog('[AudioMonitoring] Saving day/night mode:', dayNightMode);\n    localStorage.setItem(STORAGE_KEYS.DAY_NIGHT_MODE, dayNightMode.toString());\n  }, [dayNightMode]);\n\n  useEffect(() => {\n    if (!hasRestoredStateRef.current) return;\n    debugLog('[AudioMonitoring] Saving day start hour:', dayStartHour);\n    localStorage.setItem(STORAGE_KEYS.DAY_START_HOUR, dayStartHour.toString());\n  }, [dayStartHour]);\n\n  useEffect(() => {\n    if (!hasRestoredStateRef.current) return;\n    debugLog('[AudioMonitoring] Saving day end hour:', dayEndHour);\n    localStorage.setItem(STORAGE_KEYS.DAY_END_HOUR, dayEndHour.toString());\n  }, [dayEndHour]);\n\n  useEffect(() => {\n    if (!hasRestoredStateRef.current) return;\n    debugLog('[AudioMonitoring] Saving night ramp duration:', nightRampDuration);\n    localStorage.setItem(STORAGE_KEYS.NIGHT_RAMP_DURATION, nightRampDuration.toString());\n  }, [nightRampDuration]);\n\n  useEffect(() => {\n    if (!hasRestoredStateRef.current) return;\n    debugLog('[AudioMonitoring] Saving sustain duration:', sustainDuration);\n    localStorage.setItem(STORAGE_KEYS.SUSTAIN_DURATION, sustainDuration.toString());\n  }, [sustainDuration]);\n\n  useEffect(() => {\n    if (!hasRestoredStateRef.current) return;\n    debugLog('[AudioMonitoring] Saving disable delay:', disableDelay);\n    localStorage.setItem(STORAGE_KEYS.DISABLE_DELAY, disableDelay.toString());\n  }, [disableDelay]);\n\n  useEffect(() => {\n    if (!hasRestoredStateRef.current) return;\n    debugLog('[AudioMonitoring] Saving logging enabled:', loggingEnabled);\n    localStorage.setItem(STORAGE_KEYS.LOGGING_ENABLED, loggingEnabled.toString());\n  }, [loggingEnabled]);\n\n  useEffect(() => {\n    if (!hasRestoredStateRef.current) return;\n    debugLog('[AudioMonitoring] Saving recording enabled:', recordingEnabled);\n    localStorage.setItem(STORAGE_KEYS.RECORDING_ENABLED, recordingEnabled.toString());\n  }, [recordingEnabled]);\n\n  useEffect(() => {\n    if (!hasRestoredStateRef.current) return;\n    debugLog('[AudioMonitoring] Saving global volume mode:', useGlobalVolume);\n    localStorage.setItem(STORAGE_KEYS.USE_GLOBAL_VOLUME, useGlobalVolume.toString());\n  }, [useGlobalVolume]);\n\n  // Watch for target volume changes - restart ramp if speakers are enabled\n  useEffect(() => {\n    if (!hasRestoredStateRef.current) return;\n\n    // Only restart ramp if:\n    // 1. Speakers are currently enabled\n    // 2. Not currently controlling speakers\n    // 3. Speakers were ALREADY enabled (don't trigger on initial enable)\n    if (speakersEnabled && !controllingSpakersRef.current) {\n      // Check if this is the initial enable (currentVolume should still be 0)\n      const currentVolume = currentVolumeRef.current;\n\n      // Don't start ramp on initial monitoring start - wait for audio detection\n      // Only start ramp when targetVolume changes while already monitoring\n      if (currentVolume > 0 || audioDetected) {\n        debugLog(`[AudioMonitoring] Target volume changed, restarting ramp from ${currentVolume}% to ${targetVolume}%`);\n        startVolumeRamp(currentVolume);\n      } else {\n        debugLog(`[AudioMonitoring] Speakers enabled but waiting for audio detection before ramping`);\n      }\n    }\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [targetVolume, speakersEnabled]);\n\n  // Set volume on all linked speakers (8180s)\n  // volumePercent is the \"ramp percentage\" (0-100)\n  // If useGlobalVolume=true: all speakers use volumePercent directly\n  // If useGlobalVolume=false: volumePercent is scaled by each speaker's maxVolume\n  const setDevicesVolume = useCallback(async (volumePercent: number) => {\n    const linkedSpeakerIds = new Set<string>();\n\n    // Safety check: ensure selectedDevices is iterable\n    const safeSelectedDevices = selectedDevices || [];\n\n    for (const deviceId of safeSelectedDevices) {\n      const device = devices.find(d => d.id === deviceId);\n      if (!device) continue;\n\n      if (device.type === \"8301\" && device.linkedSpeakerIds) {\n        device.linkedSpeakerIds.forEach(id => linkedSpeakerIds.add(id));\n      }\n    }\n\n    debugLog(`[AudioMonitoring] setDevicesVolume(${volumePercent}%) - processing ${linkedSpeakerIds.size} speakers`);\n\n    const volumePromises = Array.from(linkedSpeakerIds).map(async (speakerId) => {\n      const speaker = devices.find(d => d.id === speakerId);\n      if (!speaker) {\n        debugLog(`[AudioMonitoring] Speaker ${speakerId} not found in devices array`);\n        return;\n      }\n\n      // Skip speakers without proper credentials\n      if (!speaker.ipAddress || !speaker.apiPassword) {\n        console.warn(`[AudioMonitoring] Skipping ${speaker.name || speakerId}: missing IP or password`);\n        return;\n      }\n\n      // Calculate actual volume based on mode\n      let actualVolume: number;\n      if (useGlobalVolume) {\n        // Global mode: all speakers use targetVolume (with ramping if enabled)\n        // volumePercent comes from the ramp (0-100% of targetVolume)\n        actualVolume = volumePercent;\n        debugLog(`[AudioMonitoring] GLOBAL MODE - Setting ${speaker.name} to ${actualVolume.toFixed(0)}%`);\n      } else {\n        // Individual mode: each speaker ramps to its own maxVolume\n        // volumePercent represents the ramp progress (0-100%)\n        // At 0%: speaker is at 0%, at 100%: speaker is at its maxVolume\n        const speakerMaxVolume = speaker.maxVolume ?? 100;\n        actualVolume = (volumePercent / 100) * speakerMaxVolume;\n        debugLog(`[AudioMonitoring] INDIVIDUAL MODE - Setting ${speaker.name} to ${volumePercent.toFixed(0)}% of its max ${speakerMaxVolume}% = ${actualVolume.toFixed(0)}% (Level ${Math.round(actualVolume/10)})`);\n      }\n\n      // Convert 0-100% to dB\n      // SPECIAL CASE: 0% = idle volume (IDLE state - quietest before needing multicast control)\n      // Normal range: Algo expects 1=-27dB, 2=-24dB, ... 10=0dB\n      // Formula: dB = (level - 10) * 3\n      let volumeDbString: string;\n      if (actualVolume === 0) {\n        volumeDbString = getIdleVolumeString(); // IDLE state - level -5 (quietest volume)\n      } else {\n        const volumeScale = Math.round((actualVolume / 100) * 10);\n        const volumeDb = (volumeScale - 10) * 3;\n        volumeDbString = volumeDb === 0 ? \"0dB\" : `${volumeDb}dB`;\n      }\n\n      debugLog(`[AudioMonitoring] ${speaker.name} final: ${actualVolume.toFixed(0)}% â†’ ${volumeDbString}`);\n\n      try {\n        const response = await fetch(\"/api/algo/settings\", {\n          method: \"POST\",\n          headers: { \"Content-Type\": \"application/json\" },\n          body: JSON.stringify({\n            ipAddress: speaker.ipAddress,\n            password: speaker.apiPassword,\n            authMethod: speaker.authMethod || \"standard\",\n            settings: {\n              \"audio.page.vol\": volumeDbString,\n            },\n          }),\n        });\n\n        if (!response.ok) {\n          // Only log as warning (not error) - offline speakers are expected\n          const errorText = await response.text().catch(() => 'Unknown error');\n          debugLog(`[AudioMonitoring] âŒ Failed to set ${speaker.name} volume: ${errorText}`);\n        } else {\n          debugLog(`[AudioMonitoring] âœ“ Successfully set ${speaker.name} to ${volumeDbString}`);\n        }\n      } catch (error) {\n        // Network error - speaker might be offline, just skip silently\n        debugLog(`[AudioMonitoring] âŒ Network error setting ${speaker.name} volume`);\n      }\n    });\n\n    // Use allSettled to continue even if some speakers fail\n    await Promise.allSettled(volumePromises);\n    debugLog(`[AudioMonitoring] setDevicesVolume(${volumePercent}%) - completed`);\n  }, [selectedDevices, devices, useGlobalVolume]);\n\n  // Helper function to determine if it's currently daytime\n  const isDaytime = useCallback(() => {\n    const now = new Date();\n    const currentHour = now.getHours();\n    return currentHour >= dayStartHour && currentHour < dayEndHour;\n  }, [dayStartHour, dayEndHour]);\n\n  // Get the effective ramp duration based on settings\n  const getEffectiveRampDuration = useCallback(() => {\n    // If ramp is disabled, return 0 (instant)\n    if (!rampEnabled) {\n      debugLog('[AudioMonitoring] Ramp disabled - instant volume');\n      return 0;\n    }\n\n    // If day/night mode is enabled, check time of day\n    if (dayNightMode) {\n      if (isDaytime()) {\n        debugLog('[AudioMonitoring] Daytime detected - instant volume');\n        return 0; // Instant during day\n      } else {\n        debugLog(`[AudioMonitoring] Nighttime detected - ${nightRampDuration}s ramp`);\n        return nightRampDuration * 1000; // Night ramp duration in ms\n      }\n    }\n\n    // Otherwise use the manual ramp duration setting\n    debugLog(`[AudioMonitoring] Manual mode - ${rampDuration}s ramp`);\n    return rampDuration * 1000;\n  }, [rampEnabled, dayNightMode, isDaytime, rampDuration, nightRampDuration]);\n\n  // Set all speakers to getIdleVolumeString() (idle state - quietest volume before needing multicast control)\n  const setDevicesVolumeToIdle = useCallback(async () => {\n    const linkedSpeakerIds = new Set<string>();\n\n    for (const deviceId of selectedDevices) {\n      const device = devices.find(d => d.id === deviceId);\n      if (!device) continue;\n\n      if (device.type === \"8301\" && device.linkedSpeakerIds) {\n        device.linkedSpeakerIds.forEach(id => linkedSpeakerIds.add(id));\n      }\n    }\n\n    debugLog(`[AudioMonitoring] Setting ${linkedSpeakerIds.size} speakers to IDLE (${getIdleVolumeString()})`);\n\n    const volumePromises = Array.from(linkedSpeakerIds).map(async (speakerId) => {\n      const speaker = devices.find(d => d.id === speakerId);\n      if (!speaker || !speaker.ipAddress || !speaker.apiPassword) return;\n\n      try {\n        await fetch(\"/api/algo/settings\", {\n          method: \"POST\",\n          headers: { \"Content-Type\": \"application/json\" },\n          body: JSON.stringify({\n            ipAddress: speaker.ipAddress,\n            password: speaker.apiPassword,\n            authMethod: speaker.authMethod || \"standard\",\n            settings: {\n              \"audio.page.vol\": getIdleVolumeString(), // IDLE state - quietest volume (level -5)\n            },\n          }),\n        });\n        debugLog(`[AudioMonitoring] âœ“ Set ${speaker.name} to IDLE (${getIdleVolumeString()})`);\n      } catch (error) {\n        debugLog(`[AudioMonitoring] âŒ Failed to set ${speaker.name} to idle`);\n      }\n    });\n\n    await Promise.allSettled(volumePromises);\n  }, [selectedDevices, devices]);\n\n  // Ramp volume from startFrom to target\n  // IMPORTANT: Ramp now starts at 10% (level 1), NOT 0%, to skip inaudible negative dB levels\n  const startVolumeRamp = useCallback((startFrom: number = 0) => {\n    if (volumeRampIntervalRef.current) {\n      clearInterval(volumeRampIntervalRef.current);\n    }\n\n    const effectiveRampDuration = getEffectiveRampDuration();\n\n    // Individual mode: Ramp to 100% (each speaker will scale to its maxVolume)\n    // Global mode: Ramp to targetVolume (all speakers use same volume)\n    const rampTarget = useGlobalVolume ? targetVolume : 100;\n\n    // If ramp duration is 0 (instant), jump directly from idle volume to target volume\n    if (effectiveRampDuration === 0) {\n      if (useGlobalVolume) {\n        debugLog(`[AudioMonitoring] GLOBAL MODE - Instant jump: ${getIdleVolumeString()} â†’ ${targetVolume}%`);\n      } else {\n        debugLog(`[AudioMonitoring] INDIVIDUAL MODE - Instant jump: ${getIdleVolumeString()} â†’ each speaker to its max`);\n      }\n      currentVolumeRef.current = rampTarget;\n      setDevicesVolume(rampTarget);\n      return;\n    }\n\n    // OPTIMIZATION: Start ramp at level 1 (10%), NOT 0%\n    // This skips all the inaudible negative dB levels (getIdleVolumeString(), -30dB, -27dB, etc.)\n    // Ramp: getIdleVolumeString() (static) â†’ 10% (audible) â†’ 20% â†’ ... â†’ target (much faster!)\n    const rampStart = 10; // Level 1 (10%) = -27dB (first audible level)\n    currentVolumeRef.current = rampStart;\n\n    const stepInterval = 500;\n    const steps = effectiveRampDuration / stepInterval;\n    const volumeDiff = rampTarget - rampStart;\n    const volumeIncrement = volumeDiff / steps;\n\n    if (useGlobalVolume) {\n      debugLog(`[AudioMonitoring] GLOBAL MODE - Optimized ramp: ${getIdleVolumeString()} â†’ ${rampStart}% â†’ ${targetVolume}% over ${effectiveRampDuration/1000}s`);\n    } else {\n      debugLog(`[AudioMonitoring] INDIVIDUAL MODE - Optimized ramp: ${getIdleVolumeString()} â†’ ${rampStart}% â†’ 100% (each speaker to its max) over ${effectiveRampDuration/1000}s`);\n    }\n\n    // Set initial volume to level 1 (10%) - skip inaudible levels!\n    setDevicesVolume(rampStart);\n\n    volumeRampIntervalRef.current = setInterval(() => {\n      currentVolumeRef.current += volumeIncrement;\n\n      if (volumeIncrement > 0 && currentVolumeRef.current >= rampTarget) {\n        // Ramping up\n        currentVolumeRef.current = rampTarget;\n        setDevicesVolume(rampTarget);\n        if (volumeRampIntervalRef.current) {\n          clearInterval(volumeRampIntervalRef.current);\n          volumeRampIntervalRef.current = null;\n        }\n        debugLog(`[AudioMonitoring] Volume ramp complete at ${rampTarget}%`);\n      } else if (volumeIncrement < 0 && currentVolumeRef.current <= rampTarget) {\n        // Ramping down\n        currentVolumeRef.current = rampTarget;\n        setDevicesVolume(rampTarget);\n        if (volumeRampIntervalRef.current) {\n          clearInterval(volumeRampIntervalRef.current);\n          volumeRampIntervalRef.current = null;\n        }\n        debugLog(`[AudioMonitoring] Volume ramp complete at ${rampTarget}%`);\n      } else {\n        setDevicesVolume(currentVolumeRef.current);\n      }\n    }, stepInterval);\n  }, [targetVolume, useGlobalVolume, setDevicesVolume, getEffectiveRampDuration]);\n\n  const stopVolumeRamp = useCallback(() => {\n    if (volumeRampIntervalRef.current) {\n      clearInterval(volumeRampIntervalRef.current);\n      volumeRampIntervalRef.current = null;\n    }\n    currentVolumeRef.current = 0;\n    // Set all speakers to getIdleVolumeString() (quietest volume - still has static at this level)\n    setDevicesVolumeToIdle();\n  }, []);\n\n  // Auto-detect day/night mode changes while monitoring (24/7 operation)\n  useEffect(() => {\n    // Clear any existing interval first to prevent memory leaks\n    if (dayNightCheckIntervalRef.current) {\n      clearInterval(dayNightCheckIntervalRef.current);\n      dayNightCheckIntervalRef.current = null;\n    }\n\n    // Only run if day/night mode is enabled\n    if (!dayNightMode) {\n      previousDayModeRef.current = null;\n      return;\n    }\n\n    // Check every minute for day/night transitions\n    dayNightCheckIntervalRef.current = setInterval(() => {\n      // Calculate current day/night status directly to avoid function dependency\n      const now = new Date();\n      const currentHour = now.getHours();\n      const currentIsDaytime = currentHour >= dayStartHour && currentHour < dayEndHour;\n\n      // Initialize on first run\n      if (previousDayModeRef.current === null) {\n        previousDayModeRef.current = currentIsDaytime;\n        debugLog(`[AudioMonitoring] Day/night monitor initialized: ${currentIsDaytime ? 'DAY' : 'NIGHT'}`);\n        return;\n      }\n\n      // Check if day/night mode changed\n      if (previousDayModeRef.current !== currentIsDaytime) {\n        debugLog(`[AudioMonitoring] â° Day/night mode changed: ${previousDayModeRef.current ? 'DAY' : 'NIGHT'} â†’ ${currentIsDaytime ? 'DAY' : 'NIGHT'}`);\n        previousDayModeRef.current = currentIsDaytime;\n\n        // If speakers are currently enabled, restart the ramp with new settings\n        // Use refs to check current state without adding to dependencies\n        if (speakersEnabled && !controllingSpakersRef.current) {\n          const currentVolume = currentVolumeRef.current;\n          debugLog(`[AudioMonitoring] Restarting volume ramp due to day/night change from ${currentVolume}%`);\n          startVolumeRamp(currentVolume);\n        }\n      }\n    }, 60000); // Check every 60 seconds\n\n    debugLog(`[AudioMonitoring] Day/night checker started (enabled: ${dayNightMode})`);\n\n    return () => {\n      if (dayNightCheckIntervalRef.current) {\n        debugLog(`[AudioMonitoring] Day/night checker stopped (cleanup)`);\n        clearInterval(dayNightCheckIntervalRef.current);\n        dayNightCheckIntervalRef.current = null;\n      }\n    };\n    // Only depend on stable values - not functions\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [dayNightMode, dayStartHour, dayEndHour]);\n\n  // Set paging device multicast mode (0=disabled, 1=transmitter, 2=receiver)\n  const setPagingMulticast = useCallback(async (mode: 0 | 1 | 2) => {\n    const pagingDevices = devices.filter(d => d.type === \"8301\");\n\n    if (pagingDevices.length === 0) {\n      debugLog('[AudioMonitoring] No paging devices found');\n      return;\n    }\n\n    debugLog(`[AudioMonitoring] Setting ${pagingDevices.length} paging device(s) to multicast mode ${mode}`);\n\n    await Promise.allSettled(\n      pagingDevices.map(async (paging) => {\n        try {\n          await fetch(\"/api/algo/speakers/mcast\", {\n            method: \"POST\",\n            headers: { \"Content-Type\": \"application/json\" },\n            body: JSON.stringify({\n              speakers: [{\n                ipAddress: paging.ipAddress,\n                password: paging.apiPassword,\n                authMethod: paging.authMethod,\n              }],\n              mode,\n            }),\n          });\n          debugLog(`[AudioMonitoring] âœ“ Set ${paging.name} to mode ${mode}`);\n        } catch (error) {\n          console.error(`Failed to set ${paging.name} multicast mode:`, error);\n        }\n      })\n    );\n  }, [devices]);\n\n  // Set all speakers multicast mode (0=disabled, 1=transmitter, 2=receiver)\n  const setSpeakersMulticast = useCallback(async (mode: 0 | 1 | 2) => {\n    const linkedSpeakerIds = new Set<string>();\n\n    for (const deviceId of selectedDevices) {\n      const device = devices.find(d => d.id === deviceId);\n      if (!device) continue;\n\n      if (device.type === \"8301\" && device.linkedSpeakerIds) {\n        device.linkedSpeakerIds.forEach(id => linkedSpeakerIds.add(id));\n      }\n    }\n\n    const speakers = Array.from(linkedSpeakerIds)\n      .map(id => devices.find(d => d.id === id))\n      .filter((s): s is AlgoDevice => !!s);\n\n    if (speakers.length === 0) {\n      debugLog('[AudioMonitoring] No speakers to control');\n      return;\n    }\n\n    debugLog(`[AudioMonitoring] Setting ${speakers.length} speakers to multicast mode ${mode}`);\n\n    await Promise.allSettled(\n      speakers.map(async (speaker) => {\n        try {\n          await fetch(\"/api/algo/speakers/mcast\", {\n            method: \"POST\",\n            headers: { \"Content-Type\": \"application/json\" },\n            body: JSON.stringify({\n              speakers: [{\n                ipAddress: speaker.ipAddress,\n                password: speaker.apiPassword,\n                authMethod: speaker.authMethod,\n              }],\n              mode,\n            }),\n          });\n          debugLog(`[AudioMonitoring] âœ“ Set ${speaker.name} to mode ${mode}`);\n        } catch (error) {\n          console.error(`Failed to set ${speaker.name} multicast mode:`, error);\n        }\n      })\n    );\n  }, [selectedDevices, devices]);\n\n  // Enable/disable speakers (LEGACY - kept for backward compatibility)\n  const controlSpeakers = useCallback(async (enable: boolean) => {\n    const allSpeakerPromises: Promise<void>[] = [];\n\n    for (const deviceId of selectedDevices) {\n      const device = devices.find(d => d.id === deviceId);\n      if (!device) continue;\n\n      if (device.type === \"8301\" && device.linkedSpeakerIds && device.linkedSpeakerIds.length > 0) {\n        const linkedSpeakers = devices.filter(d => device.linkedSpeakerIds?.includes(d.id));\n\n        debugLog(`[AudioMonitoring] ${enable ? 'Enabling' : 'Disabling'} ${linkedSpeakers.length} speakers for ${device.name}`);\n\n        // Control each speaker individually for better error resilience\n        linkedSpeakers.forEach(speaker => {\n          const promise = (async () => {\n            try {\n              const response = await fetch(\"/api/algo/speakers/mcast\", {\n                method: \"POST\",\n                headers: { \"Content-Type\": \"application/json\" },\n                body: JSON.stringify({\n                  speakers: [{\n                    ipAddress: speaker.ipAddress,\n                    password: speaker.apiPassword,\n                    authMethod: speaker.authMethod,\n                  }],\n                  enable,\n                }),\n              });\n\n              if (!response.ok) {\n                console.error(`Failed to ${enable ? 'enable' : 'disable'} speaker ${speaker.name}: HTTP ${response.status}`);\n              } else {\n                debugLog(`[AudioMonitoring] Successfully ${enable ? 'enabled' : 'disabled'} ${speaker.name}`);\n              }\n            } catch (error) {\n              console.error(`Failed to control speaker ${speaker.name}:`, error);\n              // Continue with other speakers - don't throw\n            }\n          })();\n          allSpeakerPromises.push(promise);\n        });\n      }\n    }\n\n    // Wait for all speakers to complete (parallel execution)\n    // Individual failures won't crash the system\n    await Promise.allSettled(allSpeakerPromises);\n  }, [selectedDevices, devices]);\n\n  // PoE Device Controls\n  const controlPoEDevices = useCallback(async (enable: boolean) => {\n    debugLog(`[PoE Control] Total PoE devices: ${poeDevices.length}`);\n\n    // Get PoE devices in auto mode\n    const autoPoEDevices = poeDevices.filter(d => d.mode === \"auto\");\n\n    debugLog(`[PoE Control] Auto mode PoE devices: ${autoPoEDevices.length}`);\n\n    if (autoPoEDevices.length === 0) {\n      debugLog('[PoE Control] No PoE devices in auto mode');\n      return;\n    }\n\n    // Get active paging devices (8301) from selected devices\n    const activePagingDeviceIds = selectedDevices.filter(deviceId => {\n      const device = devices.find(d => d.id === deviceId);\n      return device && device.type === \"8301\";\n    });\n\n    debugLog(`[PoE Control] Selected devices: ${selectedDevices.length}, Active paging devices (8301): ${activePagingDeviceIds.length}`, activePagingDeviceIds);\n\n    // Filter PoE devices:\n    // - Only control devices that are linked to at least one active paging device\n    // - If device has no linkedPagingDeviceIds, DON'T auto-control (user manages it manually or it's always on)\n    const eligiblePoEDevices = autoPoEDevices.filter(poeDevice => {\n      // If no paging devices are linked, DON'T auto-control this device\n      if (!poeDevice.linkedPagingDeviceIds || poeDevice.linkedPagingDeviceIds.length === 0) {\n        debugLog(`[PoE Control] Device \"${poeDevice.name}\" has no linked paging devices - skipping`);\n        return false;\n      }\n\n      // If paging devices are linked, check if any of them are active\n      const hasActivePagingDevice = poeDevice.linkedPagingDeviceIds.some(\n        linkedId => activePagingDeviceIds.includes(linkedId)\n      );\n\n      if (!hasActivePagingDevice) {\n        debugLog(`[PoE Control] Device \"${poeDevice.name}\" linked paging devices not active - skipping. Linked: ${poeDevice.linkedPagingDeviceIds.join(',')}, Active: ${activePagingDeviceIds.join(',')}`);\n      } else {\n        debugLog(`[PoE Control] Device \"${poeDevice.name}\" is eligible (linked paging device is active)`);\n      }\n\n      return hasActivePagingDevice;\n    });\n\n    if (eligiblePoEDevices.length === 0) {\n      debugLog(`[PoE Control] No eligible PoE devices to ${enable ? 'enable' : 'disable'} (no linked paging devices active)`);\n      return;\n    }\n\n    debugLog(`[PoE Control] ${enable ? 'Enabling' : 'Disabling'} ${eligiblePoEDevices.length} PoE devices (${activePagingDeviceIds.length} paging devices active)`);\n\n    // Log PoE control action\n    addLog({\n      type: enable ? \"speakers_enabled\" : \"speakers_disabled\",\n      message: `PoE: ${enable ? 'ON' : 'OFF'} - ${eligiblePoEDevices.map(d => d.name).join(', ')}`,\n    });\n\n    const promises = eligiblePoEDevices.map(async (device) => {\n      try {\n        const response = await fetch(\"/api/poe/toggle\", {\n          method: \"POST\",\n          headers: { \"Content-Type\": \"application/json\" },\n          body: JSON.stringify({\n            deviceId: device.id,\n            enabled: enable,\n          }),\n        });\n\n        if (!response.ok) {\n          console.error(`Failed to ${enable ? 'enable' : 'disable'} PoE device ${device.name}: HTTP ${response.status}`);\n          addLog({\n            type: enable ? \"speakers_enabled\" : \"speakers_disabled\",\n            message: `âš ï¸ PoE ${device.name} failed: HTTP ${response.status}`,\n          });\n        } else {\n          debugLog(`[PoE Control] Successfully ${enable ? 'enabled' : 'disabled'} ${device.name}`);\n        }\n      } catch (error) {\n        console.error(`Failed to control PoE device ${device.name}:`, error);\n        addLog({\n          type: enable ? \"speakers_enabled\" : \"speakers_disabled\",\n          message: `âš ï¸ PoE ${device.name} error: ${error instanceof Error ? error.message : 'Unknown error'}`,\n        });\n      }\n    });\n\n    await Promise.allSettled(promises);\n  }, [poeDevices, selectedDevices, devices, addLog]);\n\n  // Emergency Controls\n  const emergencyKillAll = useCallback(async () => {\n    debugLog('[AudioMonitoring] EMERGENCY: Killing all speakers');\n    addLog({\n      type: \"speakers_disabled\",\n      message: \"EMERGENCY KILL: Shutting down paging and all speakers IMMEDIATELY\",\n    });\n\n    // NEW FLOW: Emergency shutdown\n    // 1. Mute all speakers to getIdleVolumeString()\n    await setDevicesVolume(0);\n\n    // 2. Disable paging transmitter (INSTANT silence - no more audio broadcast!)\n    await setPagingMulticast(0);\n\n    // 3. Disable all speaker receivers\n    await setSpeakersMulticast(0);\n\n    // Reset state\n    setSpeakersEnabled(false);\n    setAudioDetected(false);\n    currentVolumeRef.current = 0;\n    if (volumeRampIntervalRef.current) {\n      clearInterval(volumeRampIntervalRef.current);\n      volumeRampIntervalRef.current = null;\n    }\n\n    debugLog(`[AudioMonitoring] âœ“ EMERGENCY KILL COMPLETE: All devices mode 0, volume ${getIdleVolumeString()}`);\n  }, [setDevicesVolume, setPagingMulticast, setSpeakersMulticast, addLog]);\n\n  const emergencyEnableAll = useCallback(async () => {\n    debugLog('[AudioMonitoring] EMERGENCY: Enabling all speakers');\n    addLog({\n      type: \"speakers_enabled\",\n      message: \"EMERGENCY ENABLE: Activating paging and all speakers at target volume\",\n    });\n\n    // NEW FLOW: Emergency enable\n    // 1. Set speakers to mode 2 (receivers)\n    await setSpeakersMulticast(2);\n\n    // 2. Enable paging transmitter (mode 1 - START broadcasting!)\n    await setPagingMulticast(1);\n\n    // 3. Set to target volume (instant - no ramp in emergency)\n    await setDevicesVolume(targetVolume);\n\n    setSpeakersEnabled(true);\n    currentVolumeRef.current = targetVolume;\n\n    debugLog('[AudioMonitoring] âœ“ EMERGENCY ENABLE COMPLETE: Paging ON, Speakers listening, Volume set');\n  }, [setSpeakersMulticast, setPagingMulticast, setDevicesVolume, targetVolume, addLog]);\n\n  const controlSingleSpeaker = useCallback(async (speakerId: string, enable: boolean) => {\n    const speaker = devices.find(d => d.id === speakerId);\n    if (!speaker) {\n      console.error(`Speaker ${speakerId} not found`);\n      return;\n    }\n\n    debugLog(`[AudioMonitoring] ${enable ? 'Enabling' : 'Disabling'} single speaker: ${speaker.name}`);\n    addLog({\n      type: enable ? \"speakers_enabled\" : \"speakers_disabled\",\n      message: `${enable ? 'Enabled' : 'Disabled'} speaker: ${speaker.name}`,\n    });\n\n    try {\n      // Control multicast\n      await fetch(\"/api/algo/speakers/mcast\", {\n        method: \"POST\",\n        headers: { \"Content-Type\": \"application/json\" },\n        body: JSON.stringify({\n          speakers: [{\n            ipAddress: speaker.ipAddress,\n            password: speaker.apiPassword,\n            authMethod: speaker.authMethod,\n          }],\n          enable,\n        }),\n      });\n\n      // If disabling, also mute\n      if (!enable) {\n        await fetch(\"/api/algo/settings\", {\n          method: \"POST\",\n          headers: { \"Content-Type\": \"application/json\" },\n          body: JSON.stringify({\n            ipAddress: speaker.ipAddress,\n            password: speaker.apiPassword,\n            authMethod: speaker.authMethod,\n            settings: { \"audio.page.vol\": getIdleVolumeString() }, // IDLE state - eliminates buzzing\n          }),\n        });\n      }\n    } catch (error) {\n      console.error(`Failed to control speaker ${speaker.name}:`, error);\n    }\n  }, [devices, addLog]);\n\n  // Check connectivity of all linked speakers\n  const checkSpeakerConnectivity = useCallback(async () => {\n    const linkedSpeakerIds = new Set<string>();\n\n    // Safety check: ensure selectedDevices is iterable\n    const safeSelectedDevices = selectedDevices || [];\n\n    // Get all linked speakers from selected paging devices\n    for (const deviceId of safeSelectedDevices) {\n      const device = devices.find(d => d.id === deviceId);\n      if (!device) continue;\n      if (device.type === \"8301\" && device.linkedSpeakerIds) {\n        device.linkedSpeakerIds.forEach(id => linkedSpeakerIds.add(id));\n      }\n    }\n\n    if (linkedSpeakerIds.size === 0) {\n      setSpeakerStatuses([]);\n      return;\n    }\n\n    // Build device list for health check API\n    const speakersToCheck = Array.from(linkedSpeakerIds)\n      .map(id => devices.find(d => d.id === id))\n      .filter((s): s is AlgoDevice => !!s && !!s.ipAddress && !!s.apiPassword);\n\n    if (speakersToCheck.length === 0) {\n      setSpeakerStatuses([]);\n      return;\n    }\n\n    debugLog(`[AudioMonitoring] Checking connectivity for ${speakersToCheck.length} speakers...`);\n\n    try {\n      const response = await fetch(\"/api/algo/health\", {\n        method: \"POST\",\n        headers: { \"Content-Type\": \"application/json\" },\n        body: JSON.stringify({\n          devices: speakersToCheck.map(s => ({\n            id: s.id,\n            ipAddress: s.ipAddress,\n            apiPassword: s.apiPassword,\n            authMethod: s.authMethod || \"standard\",\n          })),\n          timeout: 3000,\n        }),\n      });\n\n      if (!response.ok) {\n        throw new Error(`Health check failed: ${response.status}`);\n      }\n\n      const result = await response.json();\n\n      // Convert API response to SpeakerStatus array\n      const statuses: SpeakerStatus[] = result.devices.map((d: { id: string; ipAddress: string; isOnline: boolean; error?: string }) => {\n        const speaker = devices.find(s => s.id === d.id);\n        return {\n          speakerId: d.id,\n          speakerName: speaker?.name || 'Unknown',\n          ipAddress: d.ipAddress,\n          isOnline: d.isOnline,\n          lastChecked: new Date(),\n          errorMessage: d.error,\n        };\n      });\n\n      setSpeakerStatuses(statuses);\n\n      const onlineCount = statuses.filter(s => s.isOnline).length;\n      const offlineCount = statuses.filter(s => !s.isOnline).length;\n\n      addLog({\n        type: offlineCount > 0 ? \"speakers_disabled\" : \"speakers_enabled\",\n        message: `Connectivity check: ${onlineCount} online, ${offlineCount} offline`,\n      });\n\n      debugLog(`[AudioMonitoring] Connectivity check complete: ${onlineCount} online, ${offlineCount} offline`);\n    } catch (error) {\n      console.error('[AudioMonitoring] Connectivity check failed:', error);\n      // Set all as unknown status on error\n      const statuses: SpeakerStatus[] = speakersToCheck.map(s => ({\n        speakerId: s.id,\n        speakerName: s.name || 'Unknown',\n        ipAddress: s.ipAddress || 'Unknown',\n        isOnline: false,\n        lastChecked: new Date(),\n        errorMessage: 'Check failed',\n      }));\n      setSpeakerStatuses(statuses);\n    }\n  }, [selectedDevices, devices, addLog]);\n\n  // Audio activity detection with sustained audio requirement\n  useEffect(() => {\n    if (!isCapturing) {\n      // Clean up sustained audio tracking when not capturing\n      if (sustainedAudioStartRef.current) {\n        sustainedAudioStartRef.current = null;\n      }\n      return;\n    }\n\n    // Use configurable disable delay (default 3 seconds)\n\n    if (audioLevel > audioThreshold) {\n      // Audio is above threshold\n\n      // Start tracking sustained audio if not already tracking\n      // Note: speakersEnabled is always true during monitoring, use audioDetected instead\n      if (!sustainedAudioStartRef.current && !audioDetected) {\n        sustainedAudioStartRef.current = Date.now();\n        debugLog(`[AudioMonitoring] Audio above threshold (${audioLevel.toFixed(1)}%), starting ${sustainDuration}ms sustain timer`);\n      }\n\n      // Check if audio has been sustained long enough\n      // Note: speakersEnabled is always true during monitoring (always-on mode)\n      // We use audioDetected to track if we're actively playing audio\n      if (sustainedAudioStartRef.current && !audioDetected && !controllingSpakersRef.current) {\n        const sustainedFor = Date.now() - sustainedAudioStartRef.current;\n\n        if (sustainedFor >= sustainDuration) {\n          // Audio has been sustained - ramp volume up!\n          // CRITICAL: Speakers are already listening (multicast enabled at start)\n          // We only need to ramp up volume - this is INSTANT compared to enabling multicast\n          sustainedAudioStartRef.current = null;\n          setAudioDetected(true);\n          controllingSpakersRef.current = true;\n          speakersEnabledTimeRef.current = Date.now(); // Track when audio started playing\n\n          addLog({\n            type: \"audio_detected\",\n            audioLevel,\n            audioThreshold,\n            message: rampEnabled\n              ? `Audio sustained ${sustainDuration}ms at ${audioLevel.toFixed(1)}% - ramping volume (speakers already listening)`\n              : `Audio sustained ${sustainDuration}ms at ${audioLevel.toFixed(1)}% (speakers already listening)`,\n          });\n\n          if (rampEnabled) {\n            addLog({\n              type: \"volume_change\",\n              audioLevel,\n              speakersEnabled: true,\n              volume: targetVolume,\n              message: `Volume ramping to ${targetVolume}% (paging mode 1 â†’ speakers receive audio)`,\n            });\n          } else {\n            addLog({\n              type: \"volume_change\",\n              audioLevel,\n              speakersEnabled: true,\n              volume: targetVolume,\n              message: `Speakers at operating volume ${targetVolume}% (paging mode 1 â†’ speakers receive audio)`,\n            });\n          }\n\n          (async () => {\n            // Start recording the audio\n            await startRecording();\n\n            // Enable PoE devices (lights, etc.) in auto mode\n            await controlPoEDevices(true);\n\n            // NEW FLOW: Enable paging transmitter (mode 1) - INSTANT audio!\n            // Speakers are already in mode 2 (listening), so they'll receive immediately\n            const alwaysKeepPagingOn = getAlwaysKeepPagingOn();\n            if (!alwaysKeepPagingOn) {\n              // Only toggle paging if not always on\n              debugLog('[AudioMonitoring] AUDIO DETECTED - Setting paging to mode 1 (transmitter)');\n              await setPagingMulticast(1);\n            } else {\n              debugLog('[AudioMonitoring] AUDIO DETECTED - Paging already at mode 1 (always on)');\n            }\n\n            // Then ramp the volume (only if ramp enabled)\n            if (rampEnabled) {\n              debugLog('[AudioMonitoring] Ramp ENABLED - Starting volume ramp');\n              startVolumeRamp();\n            } else {\n              debugLog('[AudioMonitoring] Ramp DISABLED - Speakers already at operating volume, no ramp needed');\n            }\n            controllingSpakersRef.current = false;\n          })();\n        }\n      }\n\n      // Clear disable timeout if audio is detected again\n      if (audioDetectionTimeoutRef.current) {\n        clearTimeout(audioDetectionTimeoutRef.current);\n        audioDetectionTimeoutRef.current = null;\n      }\n\n    } else {\n      // Audio is below threshold\n\n      // Reset sustained audio timer if it was tracking\n      if (sustainedAudioStartRef.current) {\n        debugLog(`[AudioMonitoring] Audio dropped below threshold before sustain duration`);\n        sustainedAudioStartRef.current = null;\n      }\n\n      // Start mute countdown if audio was playing\n      // Note: We DON'T disable multicast - speakers stay listening (always-on mode)\n      // We only mute the volume so speakers are ready for the next audio burst\n      if (audioDetected) {\n        if (!audioDetectionTimeoutRef.current) {\n          addLog({\n            type: \"audio_silent\",\n            audioLevel,\n            audioThreshold,\n            message: `Audio below threshold: ${audioLevel.toFixed(1)}% - starting ${disableDelay/1000}s mute countdown`,\n          });\n\n          audioDetectionTimeoutRef.current = setTimeout(() => {\n            if (!controllingSpakersRef.current) {\n              controllingSpakersRef.current = true;\n              // DON'T disable speakers - keep them listening!\n              // setSpeakersEnabled(false); // REMOVED - speakers stay on\n              setAudioDetected(false); // Just mark audio as not active\n\n              // Calculate how long audio was playing\n              const duration = speakersEnabledTimeRef.current\n                ? ((Date.now() - speakersEnabledTimeRef.current) / 1000).toFixed(1)\n                : '?';\n              speakersEnabledTimeRef.current = null;\n\n              (async () => {\n                // Stop recording and upload\n                const recordingUrl = await stopRecordingAndUpload();\n\n                // Disable PoE devices (lights, etc.) in auto mode\n                await controlPoEDevices(false);\n\n                // NEW FLOW: Disable paging transmitter (mode 0) - NO MORE AUDIO!\n                // Speakers stay in mode 2 (listening), ready for next audio\n                const alwaysKeepPagingOn = getAlwaysKeepPagingOn();\n                if (!alwaysKeepPagingOn) {\n                  // Only toggle paging if not always on\n                  debugLog('[AudioMonitoring] AUDIO ENDED - Setting paging to mode 0 (disabled)');\n                  await setPagingMulticast(0);\n                } else {\n                  debugLog('[AudioMonitoring] AUDIO ENDED - Keeping paging at mode 1 (always on)');\n                }\n\n                // Ramp down or keep at operating volume\n                if (rampEnabled) {\n                  debugLog('[AudioMonitoring] Ramp ENABLED - Ramping volume down to idle');\n                  stopVolumeRamp();\n                  await setDevicesVolume(0);\n                } else {\n                  debugLog('[AudioMonitoring] Ramp DISABLED - Keeping speakers at operating volume');\n                  // Speakers stay at operating volume - no change needed\n                }\n\n                // Log with recording URL if available\n                addLog({\n                  type: \"volume_change\",\n                  speakersEnabled: true, // Speakers STAY in mode 2 (ready)\n                  volume: rampEnabled ? 0 : targetVolume,\n                  message: rampEnabled\n                    ? `Paging OFF after ${disableDelay/1000}s silence (duration: ${duration}s) - NO STATIC!${recordingUrl ? ' ðŸŽ™ï¸ Recording saved' : ''}`\n                    : `Paging OFF after ${disableDelay/1000}s silence (duration: ${duration}s) - Speakers stay at operating volume${recordingUrl ? ' ðŸŽ™ï¸ Recording saved' : ''}`,\n                  recordingUrl: recordingUrl || undefined,\n                });\n\n                controllingSpakersRef.current = false;\n              })();\n            }\n            audioDetectionTimeoutRef.current = null;\n          }, disableDelay);\n        }\n      }\n    }\n  }, [audioLevel, isCapturing, audioDetected, speakersEnabled, audioThreshold, sustainDuration, disableDelay, controlSpeakers, setDevicesVolume, startVolumeRamp, stopVolumeRamp, targetVolume, addLog, startRecording, stopRecordingAndUpload, setPagingMulticast, controlPoEDevices]);\n\n  const startMonitoring = useCallback(async (inputDevice?: string) => {\n    debugLog('[AudioMonitoring] Starting monitoring', inputDevice);\n    addLog({\n      type: \"audio_detected\",\n      audioThreshold,\n      message: `Monitoring started with threshold: ${audioThreshold}%`,\n    });\n\n    // Start audio capture IMMEDIATELY - don't wait for speaker setup\n    // This ensures the UI responds instantly and audio is being captured\n    startCapture(inputDevice);\n\n    // Check speaker connectivity first (in background)\n    checkSpeakerConnectivity();\n\n    // NEW FLOW: Set up devices for instant response with NO STATIC\n    debugLog(`[AudioMonitoring] NEW FLOW: Setting up paging and speakers (mode 2)`);\n\n    // Run speaker setup in background - offline speakers shouldn't block monitoring\n    (async () => {\n      try {\n        // Step 1: Set speakers to starting volume (depends on ramp setting)\n        if (rampEnabled) {\n          // Ramp enabled: Start at idle volume, will ramp up when audio detected\n          debugLog(`[AudioMonitoring] Step 1: Ramp ENABLED - Setting speakers to idle volume ${getIdleVolumeString()}`);\n          await setDevicesVolume(0); // 0% = idle volume\n        } else {\n          // Ramp disabled: Start at operating volume, stay there\n          debugLog(`[AudioMonitoring] Step 1: Ramp DISABLED - Setting speakers to operating volume`);\n          await setDevicesVolume(100); // 100% scales to each speaker's maxVolume (operating volume)\n        }\n\n        // Wait briefly to ensure volume command is fully processed\n        await new Promise(resolve => setTimeout(resolve, 200));\n\n        // Step 2: Set paging device mode (check settings)\n        const alwaysKeepPagingOn = getAlwaysKeepPagingOn();\n        if (alwaysKeepPagingOn) {\n          debugLog('[AudioMonitoring] Step 2: Setting paging device to mode 1 (ALWAYS ON - transmitter)');\n          await setPagingMulticast(1);\n        } else {\n          debugLog('[AudioMonitoring] Step 2: Setting paging device to mode 0 (disabled - will toggle on audio)');\n          await setPagingMulticast(0);\n        }\n\n        // Step 3: Set all speakers to mode 2 (receiver - ready to listen)\n        debugLog('[AudioMonitoring] Step 3: Setting speakers to mode 2 (receiver)');\n        await setSpeakersMulticast(2);\n\n        setSpeakersEnabled(true); // Mark as ready\n\n        const volumeMsg = rampEnabled\n          ? `Idle Volume=${getIdleVolumeString()} (will ramp when audio detected)`\n          : `Operating Volume (ramp disabled)`;\n\n        addLog({\n          type: \"speakers_enabled\",\n          speakersEnabled: true,\n          volume: rampEnabled ? 0 : 100,\n          message: alwaysKeepPagingOn\n            ? `Monitoring ready: Paging=ALWAYS ON (Mode 1), Speakers=LISTENING, ${volumeMsg}`\n            : `Monitoring ready: Paging=OFF, Speakers=LISTENING, ${volumeMsg}`,\n        });\n\n        debugLog(`[AudioMonitoring] âœ“ Setup complete: Paging mode ${alwaysKeepPagingOn ? 1 : 0}, Speakers mode 2, ${volumeMsg}`);\n      } catch (error) {\n        console.error('[AudioMonitoring] Error during speaker setup:', error);\n        // Continue anyway - audio capture is already running\n        setSpeakersEnabled(true);\n      }\n    })();\n  }, [startCapture, audioThreshold, addLog, setDevicesVolume, setPagingMulticast, setSpeakersMulticast, checkSpeakerConnectivity]);\n\n  const stopMonitoring = useCallback(async () => {\n    debugLog('[AudioMonitoring] Stopping monitoring');\n\n    // Calculate duration if audio was playing\n    const duration = speakersEnabledTimeRef.current\n      ? ((Date.now() - speakersEnabledTimeRef.current) / 1000).toFixed(1)\n      : null;\n    speakersEnabledTimeRef.current = null;\n\n    addLog({\n      type: \"speakers_disabled\",\n      message: duration\n        ? `Monitoring stopped (audio was playing for ${duration}s)`\n        : 'Monitoring stopped - shutting down all devices',\n    });\n\n    stopCapture();\n    stopVolumeRamp();\n\n    // Clear any pending audio detection timeout\n    if (audioDetectionTimeoutRef.current) {\n      clearTimeout(audioDetectionTimeoutRef.current);\n      audioDetectionTimeoutRef.current = null;\n    }\n\n    // NEW FLOW: Clean shutdown - set everything to mode 0 and getIdleVolumeString()\n    if (!controllingSpakersRef.current) {\n      controllingSpakersRef.current = true;\n      setSpeakersEnabled(false);\n      setAudioDetected(false);\n\n      debugLog(`[AudioMonitoring] STOP: Shutting down paging and speakers to mode 0, volume ${getIdleVolumeString()}`);\n\n      // Step 1: Set speakers to idle volume\n      await setDevicesVolume(0);\n\n      // Step 2: Set paging device to mode 0 (disabled)\n      await setPagingMulticast(0);\n\n      // Step 3: Set all speakers to mode 0 (disabled)\n      await setSpeakersMulticast(0);\n\n      controllingSpakersRef.current = false;\n      debugLog(`[AudioMonitoring] âœ“ Clean shutdown complete: All devices mode 0, speakers ${getIdleVolumeString()}`);\n    }\n  }, [stopCapture, stopVolumeRamp, setDevicesVolume, setPagingMulticast, setSpeakersMulticast, addLog]);\n\n  const setVolume = useCallback((vol: number) => {\n    setVolumeState(vol);\n  }, []);\n\n  const setInputDevice = useCallback((deviceId: string) => {\n    setSelectedInputDeviceState(deviceId);\n  }, []);\n\n  const setSelectedDevices = useCallback((devs: string[]) => {\n    setSelectedDevicesState(devs);\n  }, []);\n\n  const setTargetVolume = useCallback((vol: number) => {\n    setTargetVolumeState(vol);\n  }, []);\n\n  const setAudioThreshold = useCallback((threshold: number) => {\n    setAudioThresholdState(threshold);\n  }, []);\n\n  const setRampEnabled = useCallback((enabled: boolean) => {\n    setRampEnabledState(enabled);\n  }, []);\n\n  const setRampDuration = useCallback((duration: number) => {\n    setRampDurationState(duration);\n  }, []);\n\n  const setDayNightMode = useCallback((enabled: boolean) => {\n    setDayNightModeState(enabled);\n  }, []);\n\n  const setDayStartHour = useCallback((hour: number) => {\n    setDayStartHourState(hour);\n  }, []);\n\n  const setDayEndHour = useCallback((hour: number) => {\n    setDayEndHourState(hour);\n  }, []);\n\n  const setNightRampDuration = useCallback((duration: number) => {\n    setNightRampDurationState(duration);\n  }, []);\n\n  const setSustainDuration = useCallback((duration: number) => {\n    setSustainDurationState(duration);\n  }, []);\n\n  const setDisableDelay = useCallback((delay: number) => {\n    setDisableDelayState(delay);\n  }, []);\n\n  const setLoggingEnabled = useCallback((enabled: boolean) => {\n    setLoggingEnabledState(enabled);\n  }, []);\n\n  const setRecordingEnabled = useCallback((enabled: boolean) => {\n    setRecordingEnabledState(enabled);\n  }, []);\n\n  const clearLogs = useCallback(() => {\n    setLogs([]);\n    debugLog('[AudioLog] Logs cleared');\n  }, []);\n\n  const exportLogs = useCallback(() => {\n    const header = \"Timestamp,Type,Audio Level,Threshold,Speakers,Volume,Message\\n\";\n    const rows = logs.map(log => {\n      const timestamp = new Date(log.timestamp).toLocaleString();\n      return `\"${timestamp}\",\"${log.type}\",\"${log.audioLevel ?? ''}\",\"${log.audioThreshold ?? ''}\",\"${log.speakersEnabled ?? ''}\",\"${log.volume ?? ''}\",\"${log.message}\"`;\n    }).join(\"\\n\");\n\n    return header + rows;\n  }, [logs]);\n\n  const setUseGlobalVolume = useCallback((useGlobal: boolean) => {\n    setUseGlobalVolumeState(useGlobal);\n    debugLog(`[AudioMonitoring] Volume mode changed to: ${useGlobal ? 'GLOBAL' : 'INDIVIDUAL'}`);\n  }, []);\n\n  return (\n    <AudioMonitoringContext.Provider\n      value={{\n        isCapturing,\n        audioLevel,\n        selectedInputDevice,\n        volume,\n        targetVolume,\n        audioThreshold,\n        audioDetected,\n        speakersEnabled,\n        useGlobalVolume,\n        setUseGlobalVolume,\n        rampEnabled,\n        rampDuration,\n        dayNightMode,\n        dayStartHour,\n        dayEndHour,\n        nightRampDuration,\n        sustainDuration,\n        disableDelay,\n        setRampEnabled,\n        setRampDuration,\n        setDayNightMode,\n        setDayStartHour,\n        setDayEndHour,\n        setNightRampDuration,\n        setSustainDuration,\n        setDisableDelay,\n        selectedDevices,\n        setSelectedDevices,\n        startMonitoring,\n        stopMonitoring,\n        setInputDevice,\n        setVolume,\n        setTargetVolume,\n        setAudioThreshold,\n        devices,\n        setDevices,\n        poeDevices,\n        setPoeDevices,\n        logs,\n        clearLogs,\n        exportLogs,\n        loggingEnabled,\n        setLoggingEnabled,\n        recordingEnabled,\n        setRecordingEnabled,\n        emergencyKillAll,\n        emergencyEnableAll,\n        controlSingleSpeaker,\n        speakerStatuses,\n        checkSpeakerConnectivity,\n      }}\n    >\n      {children}\n    </AudioMonitoringContext.Provider>\n  );\n}\n\nexport function useAudioMonitoring() {\n  const context = useContext(AudioMonitoringContext);\n  if (!context) {\n    throw new Error(\"useAudioMonitoring must be used within AudioMonitoringProvider\");\n  }\n  return context;\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 2578, "column": 0}, "map": {"version":3,"sources":["file:///mnt/g/files/documents/webdev/algo-app/src/contexts/realtime-sync-context.tsx"],"sourcesContent":["\"use client\";\n\nimport { createContext, useContext, useState, useEffect, useCallback, useRef } from \"react\";\nimport { useAuth } from \"@/contexts/auth-context\";\nimport { realtimeDb } from \"@/lib/firebase/config\";\nimport { ref, set, onValue, onDisconnect, serverTimestamp, remove, get } from \"firebase/database\";\nimport { usePathname, useRouter } from \"next/navigation\";\n\n// Cursor position with click animation\n// Using percentages instead of pixels to handle different screen sizes\nexport interface CursorPosition {\n  x: number; // Percentage (0-100)\n  y: number; // Percentage (0-100)\n  userId: string;\n  userName: string;\n  userRole: string;\n  color: string;\n  isClicking?: boolean;\n  timestamp: number;\n}\n\n// User presence (single session per user)\nexport interface UserPresence {\n  uid: string;\n  email: string;\n  displayName: string;\n  role: string;\n  currentPage: string;\n  isOnline: boolean;\n  lastSeen: number;\n  controlledBy: string[]; // Array of admin UIDs controlling this user\n}\n\n// Session state (all app state that gets synced)\nexport interface SessionState {\n  // Audio monitoring (separated to prevent conflicts)\n  audioInputMonitoring: boolean; // Audio input page\n  multiInputMonitoring: boolean; // Multi-input routing page\n  selectedDevices: string[];\n  volume: number;\n  targetVolume: number;\n  audioThreshold: number;\n\n  // Page navigation\n  currentPage: string;\n\n  // Ramp settings\n  rampEnabled: boolean;\n  rampDuration: number;\n  sustainDuration: number;\n  disableDelay: number;\n\n  // Input device\n  selectedInputDevice: string;\n  availableInputDevices: Array<{ deviceId: string; label: string }>; // User's available audio inputs\n\n  // Volume mode\n  useGlobalVolume: boolean;\n\n  // Day/Night mode\n  dayNightMode: boolean;\n  dayStartHour: number;\n  dayEndHour: number;\n  nightRampDuration: number;\n\n  // Logging & Recording\n  loggingEnabled: boolean;\n  recordingEnabled: boolean;\n\n  // Real-time audio state (for display only)\n  audioLevel: number;\n  audioDetected: boolean;\n  speakersEnabled: boolean;\n\n  // Scroll position (for cross-screen syncing)\n  scrollX: number;\n  scrollY: number;\n\n  // Last update info\n  lastUpdatedBy: string;\n  lastUpdatedAt: number;\n}\n\ninterface RealtimeSyncContextType {\n  // Presence\n  onlineUsers: UserPresence[];\n  myPresence: UserPresence | null;\n\n  // Control\n  isBeingControlled: boolean;\n  controllersInfo: { uid: string; name: string; color: string }[];\n  startControlling: (targetUserId: string) => Promise<void>;\n  stopControlling: (targetUserId: string) => Promise<void>;\n\n  // Viewing as (for admin)\n  viewingAsUserId: string | null; // Which user the admin is viewing as\n  viewingAsUserEmail: string | null; // Email of the user being viewed\n  setViewingAsUser: (userId: string | null) => void;\n\n  // Cursors\n  cursors: CursorPosition[];\n  updateMyCursor: (x: number, y: number, isClicking?: boolean) => void;\n\n  // Session sync\n  syncSessionState: (state: Partial<SessionState>) => Promise<void>;\n  sessionState: SessionState | null;\n}\n\nconst RealtimeSyncContext = createContext<RealtimeSyncContextType | undefined>(undefined);\n\n// Color palette for user cursors\nconst CURSOR_COLORS = [\n  \"#4a9eff\", // blue\n  \"#a855f7\", // purple\n  \"#ff5c5c\", // red\n  \"#4aff9f\", // green\n  \"#ffaa4a\", // orange\n  \"#ff69b4\", // pink\n  \"#00d9ff\", // cyan\n  \"#ffd700\", // gold\n];\n\nexport function RealtimeSyncProvider({ children }: { children: React.ReactNode }) {\n  const { user } = useAuth();\n  const pathname = usePathname();\n  const router = useRouter();\n\n  const [onlineUsers, setOnlineUsers] = useState<UserPresence[]>([]);\n  const [myPresence, setMyPresence] = useState<UserPresence | null>(null);\n  const [cursors, setCursors] = useState<CursorPosition[]>([]);\n  const [sessionState, setSessionState] = useState<SessionState | null>(null);\n  const [isBeingControlled, setIsBeingControlled] = useState(false);\n  const [controllersInfo, setControllersInfo] = useState<{ uid: string; name: string; color: string }[]>([]);\n  const [viewingAsUserId, setViewingAsUserId] = useState<string | null>(() => {\n    // Restore from sessionStorage on mount\n    if (typeof window !== 'undefined') {\n      return sessionStorage.getItem('adminViewingUserId');\n    }\n    return null;\n  });\n  const [viewingAsUserEmail, setViewingAsUserEmail] = useState<string | null>(() => {\n    // Restore from sessionStorage on mount\n    if (typeof window !== 'undefined') {\n      return sessionStorage.getItem('adminViewingUserEmail');\n    }\n    return null;\n  });\n\n  const cursorColorRef = useRef<string>(CURSOR_COLORS[0]);\n  const isAdminRef = useRef(false);\n  const navigationLockRef = useRef(false); // Prevent navigation loops\n\n  // Assign color based on user ID\n  useEffect(() => {\n    if (user) {\n      const hash = user.uid.split('').reduce((acc, char) => acc + char.charCodeAt(0), 0);\n      cursorColorRef.current = CURSOR_COLORS[hash % CURSOR_COLORS.length];\n    }\n  }, [user]);\n\n  // Set up presence system\n  useEffect(() => {\n    if (!user) return;\n\n    const presenceRef = ref(realtimeDb, `presence/${user.uid}`);\n    const myPresenceData: UserPresence = {\n      uid: user.uid,\n      email: user.email || \"\",\n      displayName: user.displayName || user.email || \"User\",\n      role: (user as any).role || \"user\",\n      currentPage: pathname || \"/\",\n      isOnline: true,\n      lastSeen: Date.now(),\n      controlledBy: [],\n    };\n\n    isAdminRef.current = myPresenceData.role === \"admin\";\n\n    // Set presence\n    set(presenceRef, myPresenceData);\n    setMyPresence(myPresenceData);\n\n    // Set up disconnect handler\n    const disconnectRef = onDisconnect(presenceRef);\n    disconnectRef.set({\n      ...myPresenceData,\n      isOnline: false,\n      lastSeen: Date.now(),\n    });\n\n    // Update page when pathname changes\n    const updatePage = async () => {\n      await set(ref(realtimeDb, `presence/${user.uid}/currentPage`), pathname);\n    };\n    updatePage();\n\n    return () => {\n      // Clean up on unmount\n      set(presenceRef, {\n        ...myPresenceData,\n        isOnline: false,\n        lastSeen: Date.now(),\n      });\n    };\n  }, [user, pathname]);\n\n  // Listen to all users' presence\n  useEffect(() => {\n    if (!user) return;\n\n    const presenceRef = ref(realtimeDb, \"presence\");\n    const unsubscribe = onValue(presenceRef, (snapshot) => {\n      const users: UserPresence[] = [];\n      snapshot.forEach((childSnapshot) => {\n        const presence = childSnapshot.val() as UserPresence;\n        if (presence && presence.uid !== user.uid) {\n          users.push(presence);\n        }\n\n        // Check if I'm being controlled\n        if (presence && presence.uid === user.uid) {\n          if (presence.controlledBy && presence.controlledBy.length > 0) {\n            setIsBeingControlled(true);\n\n            // Get controller info\n            const controllers = presence.controlledBy.map((controllerUid, index) => {\n              const controller = users.find(u => u.uid === controllerUid);\n              return {\n                uid: controllerUid,\n                name: controller?.displayName || \"Admin\",\n                color: CURSOR_COLORS[index % CURSOR_COLORS.length],\n              };\n            });\n            setControllersInfo(controllers);\n          } else {\n            // Not being controlled - clear state\n            setIsBeingControlled(false);\n            setControllersInfo([]);\n          }\n        }\n      });\n      setOnlineUsers(users);\n    });\n\n    return () => unsubscribe();\n  }, [user]);\n\n  // Listen to session state (for users being controlled or admins watching)\n  useEffect(() => {\n    if (!user) return;\n\n    // If admin is viewing as another user, listen to their session instead\n    const targetUserId = viewingAsUserId || user.uid;\n    const sessionRef = ref(realtimeDb, `sessions/${targetUserId}`);\n\n    const unsubscribe = onValue(sessionRef, (snapshot) => {\n      const state = snapshot.val() as SessionState | null;\n\n      // For admins viewing other users, always apply the state\n      // For regular users, only apply if someone else updated it\n      if (state && (viewingAsUserId || state.lastUpdatedBy !== user.uid)) {\n        setSessionState(state);\n\n        // Navigate if page changed\n        // ADMINS: Follow the user's page navigation (viewingAsUserId = true)\n        // USERS: Follow admin's navigation commands (!viewingAsUserId = true, but someone else updated)\n        const shouldNavigate = state.currentPage && state.currentPage !== pathname && !navigationLockRef.current;\n\n        if (shouldNavigate) {\n          console.log('[RealtimeSync] Navigating to:', state.currentPage, viewingAsUserId ? '(following user)' : '(following admin)');\n          navigationLockRef.current = true;\n          router.push(state.currentPage);\n          setTimeout(() => {\n            navigationLockRef.current = false;\n          }, 500);\n        }\n      }\n    });\n\n    return () => unsubscribe();\n  }, [user, pathname, router, viewingAsUserId]);\n\n  // Continuously sync current page to Firebase when pathname changes\n  useEffect(() => {\n    if (!user) return;\n\n    const syncPage = async () => {\n      // If admin is viewing a user, sync admin's page to the user's session\n      if (isAdminRef.current && viewingAsUserId) {\n        console.log('[RealtimeSync] Admin syncing page to user session:', pathname);\n        const sessionRef = ref(realtimeDb, `sessions/${viewingAsUserId}`);\n        const currentState = (await get(sessionRef)).val() || {};\n\n        await set(sessionRef, {\n          ...currentState,\n          currentPage: pathname,\n          lastUpdatedBy: user.uid,\n          lastUpdatedAt: Date.now(),\n        });\n      }\n      // Regular user - sync to own session (so admin can see)\n      else if (!viewingAsUserId) {\n        console.log('[RealtimeSync] User syncing page to own session:', pathname);\n        const sessionRef = ref(realtimeDb, `sessions/${user.uid}`);\n        const currentState = (await get(sessionRef)).val() || {};\n\n        await set(sessionRef, {\n          ...currentState,\n          currentPage: pathname,\n          lastUpdatedBy: user.uid,\n          lastUpdatedAt: Date.now(),\n        });\n      }\n    };\n\n    syncPage();\n  }, [user, pathname, viewingAsUserId]);\n\n  // Polling mechanism - admin checks user's state every 3 seconds\n  useEffect(() => {\n    if (!user || !isAdminRef.current || !viewingAsUserId) return;\n\n    console.log('[RealtimeSync] Starting polling for user state:', viewingAsUserId);\n\n    const pollInterval = setInterval(async () => {\n      const sessionRef = ref(realtimeDb, `sessions/${viewingAsUserId}`);\n      const snapshot = await get(sessionRef);\n      const state = snapshot.val() as SessionState | null;\n\n      if (state) {\n        console.log('[RealtimeSync] Polling - user current page:', state.currentPage, 'admin current page:', pathname);\n        setSessionState(state);\n\n        // If pages don't match, navigate to user's page\n        if (state.currentPage && state.currentPage !== pathname && !navigationLockRef.current) {\n          console.log('[RealtimeSync] Polling detected page mismatch - navigating to:', state.currentPage);\n          navigationLockRef.current = true;\n          router.push(state.currentPage);\n          setTimeout(() => {\n            navigationLockRef.current = false;\n          }, 500);\n        }\n      }\n    }, 3000); // Poll every 3 seconds\n\n    return () => {\n      console.log('[RealtimeSync] Stopping polling');\n      clearInterval(pollInterval);\n    };\n  }, [user, viewingAsUserId, pathname, router]);\n\n  // Track and sync scroll position\n  useEffect(() => {\n    if (!user) return;\n\n    let scrollTimeout: NodeJS.Timeout | null = null;\n    const isApplyingScroll = { current: false };\n\n    const handleScroll = () => {\n      if (isApplyingScroll.current) return;\n\n      // Debounce scroll updates\n      if (scrollTimeout) clearTimeout(scrollTimeout);\n\n      scrollTimeout = setTimeout(async () => {\n        const scrollX = window.scrollX;\n        const scrollY = window.scrollY;\n\n        // Sync scroll position to Firebase\n        if (isAdminRef.current && viewingAsUserId) {\n          // Admin scrolling - sync to user's session\n          const sessionRef = ref(realtimeDb, `sessions/${viewingAsUserId}`);\n          const currentState = (await get(sessionRef)).val() || {};\n\n          await set(sessionRef, {\n            ...currentState,\n            scrollX,\n            scrollY,\n            lastUpdatedBy: user.uid,\n            lastUpdatedAt: Date.now(),\n          });\n        } else if (!viewingAsUserId) {\n          // User scrolling - sync to own session\n          const sessionRef = ref(realtimeDb, `sessions/${user.uid}`);\n          const currentState = (await get(sessionRef)).val() || {};\n\n          await set(sessionRef, {\n            ...currentState,\n            scrollX,\n            scrollY,\n            lastUpdatedBy: user.uid,\n            lastUpdatedAt: Date.now(),\n          });\n        }\n      }, 300); // Debounce 300ms\n    };\n\n    // Apply scroll from sessionState\n    const applyScroll = () => {\n      if (!sessionState) return;\n\n      const scrollX = sessionState.scrollX;\n      const scrollY = sessionState.scrollY;\n\n      if (scrollX !== undefined && scrollY !== undefined) {\n        // Check if we need to scroll\n        if (Math.abs(window.scrollX - scrollX) > 10 || Math.abs(window.scrollY - scrollY) > 10) {\n          isApplyingScroll.current = true;\n          window.scrollTo({\n            left: scrollX,\n            top: scrollY,\n            behavior: 'smooth',\n          });\n          setTimeout(() => {\n            isApplyingScroll.current = false;\n          }, 500);\n        }\n      }\n    };\n\n    // Listen for scroll events\n    window.addEventListener('scroll', handleScroll, { passive: true });\n\n    // Apply scroll when sessionState changes (for following user/admin)\n    applyScroll();\n\n    return () => {\n      window.removeEventListener('scroll', handleScroll);\n      if (scrollTimeout) clearTimeout(scrollTimeout);\n    };\n  }, [user, viewingAsUserId, sessionState]);\n\n  // Sync session state\n  const syncSessionState = useCallback(async (state: Partial<SessionState>) => {\n    if (!user) return;\n\n    // Filter out undefined values to prevent Firebase errors\n    const filteredState: any = {};\n    Object.keys(state).forEach(key => {\n      const value = (state as any)[key];\n      if (value !== undefined) {\n        filteredState[key] = value;\n      }\n    });\n\n    // If admin is viewing a user, sync to that user's session\n    if (isAdminRef.current && viewingAsUserId) {\n      const sessionRef = ref(realtimeDb, `sessions/${viewingAsUserId}`);\n      const currentState = (await get(sessionRef)).val() || {};\n\n      await set(sessionRef, {\n        ...currentState,\n        ...filteredState,\n        currentPage: pathname,\n        lastUpdatedBy: user.uid,\n        lastUpdatedAt: Date.now(),\n      });\n      return; // Don't write to admin's own session\n    }\n\n    // Regular user or admin not controlling anyone - write to own session\n    const sessionRef = ref(realtimeDb, `sessions/${user.uid}`);\n    const currentState = (await get(sessionRef)).val() || {};\n\n    await set(sessionRef, {\n      ...currentState,\n      ...filteredState,\n      currentPage: pathname,\n      lastUpdatedBy: user.uid,\n      lastUpdatedAt: Date.now(),\n    });\n  }, [user, pathname, viewingAsUserId]);\n\n  // Update cursor position\n  const updateMyCursor = useCallback((x: number, y: number, isClicking = false) => {\n    if (!user || !myPresence) return;\n\n    // For admins: update cursor for the user they're viewing\n    if (isAdminRef.current && viewingAsUserId) {\n      // Convert pixel coordinates to percentages for cross-resolution support\n      const xPercent = (x / window.innerWidth) * 100;\n      const yPercent = (y / window.innerHeight) * 100;\n\n      const cursorRef = ref(realtimeDb, `cursors/${viewingAsUserId}/${user.uid}`);\n\n      // Set cursor position (as percentages)\n      set(cursorRef, {\n        x: xPercent,\n        y: yPercent,\n        userId: user.uid,\n        userName: myPresence.displayName,\n        userRole: myPresence.role,\n        color: cursorColorRef.current,\n        isClicking,\n        timestamp: Date.now(),\n      });\n\n      // Set up auto-cleanup on disconnect\n      const disconnectRef = onDisconnect(cursorRef);\n      disconnectRef.remove();\n    }\n  }, [user, myPresence, viewingAsUserId]);\n\n  // Listen to cursors on my screen\n  useEffect(() => {\n    if (!user) return;\n\n    const cursorsRef = ref(realtimeDb, `cursors/${user.uid}`);\n    const unsubscribe = onValue(cursorsRef, (snapshot) => {\n      const cursorsData: CursorPosition[] = [];\n      const now = Date.now();\n      const CURSOR_TIMEOUT = 10000; // 10 seconds\n\n      if (!snapshot.exists()) {\n        // No cursors - clear the state\n        console.log('[RealtimeSync] No cursors in Firebase, clearing cursor state');\n        setCursors([]);\n        return;\n      }\n\n      snapshot.forEach((childSnapshot) => {\n        const cursor = childSnapshot.val() as CursorPosition;\n        if (cursor) {\n          // Filter out stale cursors (admin disconnected)\n          if (now - cursor.timestamp < CURSOR_TIMEOUT) {\n            cursorsData.push(cursor);\n          } else {\n            // Remove stale cursor\n            console.log('[RealtimeSync] Removing stale cursor from', cursor.userName);\n            remove(childSnapshot.ref);\n          }\n        }\n      });\n\n      console.log('[RealtimeSync] Updated cursors, count:', cursorsData.length);\n      setCursors(cursorsData);\n    });\n\n    return () => unsubscribe();\n  }, [user]);\n\n  // Start controlling a user (admin only)\n  const startControlling = useCallback(async (targetUserId: string) => {\n    if (!user || !isAdminRef.current) return;\n\n    const targetPresenceRef = ref(realtimeDb, `presence/${targetUserId}/controlledBy`);\n    const currentControllers = (await get(targetPresenceRef)).val() || [];\n\n    if (!currentControllers.includes(user.uid)) {\n      const updatedControllers = [...currentControllers, user.uid];\n\n      // Set up auto-cleanup BEFORE adding ourselves\n      // When we disconnect, remove ourselves from the array\n      const disconnectRef = onDisconnect(targetPresenceRef);\n      if (currentControllers.length === 0) {\n        // If we're the only controller, remove the whole array on disconnect\n        await disconnectRef.remove();\n      } else {\n        // If there are other controllers, restore to just them (without us)\n        await disconnectRef.set(currentControllers);\n      }\n\n      // Now add ourselves to the controlledBy array\n      await set(targetPresenceRef, updatedControllers);\n    }\n  }, [user]);\n\n  // Stop controlling a user (admin only)\n  const stopControlling = useCallback(async (targetUserId: string) => {\n    if (!user || !isAdminRef.current) return;\n\n    const targetPresenceRef = ref(realtimeDb, `presence/${targetUserId}/controlledBy`);\n    const currentControllers = (await get(targetPresenceRef)).val() || [];\n\n    const updatedControllers = currentControllers.filter((uid: string) => uid !== user.uid);\n\n    // Always remove cursor when stopping control\n    await remove(ref(realtimeDb, `cursors/${targetUserId}/${user.uid}`));\n\n    // Update or remove controlledBy array\n    if (updatedControllers.length === 0) {\n      await remove(targetPresenceRef);\n    } else {\n      await set(targetPresenceRef, updatedControllers);\n    }\n\n    // Cancel the onDisconnect handler since we're manually releasing\n    const disconnectRef = onDisconnect(targetPresenceRef);\n    await disconnectRef.cancel();\n\n    // Clear viewing as user if this was the user being viewed\n    if (viewingAsUserId === targetUserId) {\n      setViewingAsUserId(null);\n      setViewingAsUserEmail(null);\n\n      // Clear from sessionStorage\n      if (typeof window !== 'undefined') {\n        sessionStorage.removeItem('adminViewingUserId');\n        sessionStorage.removeItem('adminViewingUserEmail');\n      }\n    }\n\n    console.log('[RealtimeSync] Released control of user:', targetUserId);\n  }, [user, viewingAsUserId]);\n\n  // Set which user the admin is viewing as\n  const setViewingAsUser = useCallback((userId: string | null) => {\n    if (!isAdminRef.current) return; // Only admins can view as other users\n\n    setViewingAsUserId(userId);\n\n    // Save to sessionStorage for persistence across navigation\n    if (typeof window !== 'undefined') {\n      if (userId) {\n        sessionStorage.setItem('adminViewingUserId', userId);\n      } else {\n        sessionStorage.removeItem('adminViewingUserId');\n      }\n    }\n\n    // Update email when user changes\n    if (userId) {\n      const targetUser = onlineUsers.find(u => u.uid === userId);\n      if (targetUser?.email) {\n        setViewingAsUserEmail(targetUser.email);\n        // Save email to sessionStorage too\n        if (typeof window !== 'undefined') {\n          sessionStorage.setItem('adminViewingUserEmail', targetUser.email);\n        }\n      }\n    } else {\n      setViewingAsUserEmail(null);\n      if (typeof window !== 'undefined') {\n        sessionStorage.removeItem('adminViewingUserEmail');\n      }\n    }\n  }, [onlineUsers]);\n\n  // Update viewing email when online users update (preserve viewing state)\n  useEffect(() => {\n    if (viewingAsUserId && isAdminRef.current) {\n      const targetUser = onlineUsers.find(u => u.uid === viewingAsUserId);\n      if (targetUser?.email && targetUser.email !== viewingAsUserEmail) {\n        setViewingAsUserEmail(targetUser.email);\n        // Update sessionStorage\n        if (typeof window !== 'undefined') {\n          sessionStorage.setItem('adminViewingUserEmail', targetUser.email);\n        }\n      }\n    }\n  }, [onlineUsers, viewingAsUserId, viewingAsUserEmail]);\n\n  // Restore control state on mount/navigation (admin persistence)\n  useEffect(() => {\n    if (!user || !isAdminRef.current) return;\n\n    const storedUserId = typeof window !== 'undefined' ? sessionStorage.getItem('adminViewingUserId') : null;\n\n    if (storedUserId && !viewingAsUserId) {\n      // Admin was controlling someone - restore the state\n      console.log('[RealtimeSync] Restoring admin control state for user:', storedUserId);\n      setViewingAsUserId(storedUserId);\n\n      // Try to restore email from storage or online users\n      const storedEmail = typeof window !== 'undefined' ? sessionStorage.getItem('adminViewingUserEmail') : null;\n      if (storedEmail) {\n        setViewingAsUserEmail(storedEmail);\n      } else {\n        const targetUser = onlineUsers.find(u => u.uid === storedUserId);\n        if (targetUser?.email) {\n          setViewingAsUserEmail(targetUser.email);\n        }\n      }\n    }\n  }, [user, onlineUsers, viewingAsUserId]);\n\n  const value: RealtimeSyncContextType = {\n    onlineUsers,\n    myPresence,\n    isBeingControlled,\n    controllersInfo,\n    startControlling,\n    stopControlling,\n    viewingAsUserId,\n    viewingAsUserEmail,\n    setViewingAsUser,\n    cursors,\n    updateMyCursor,\n    syncSessionState,\n    sessionState,\n  };\n\n  return (\n    <RealtimeSyncContext.Provider value={value}>\n      {children}\n    </RealtimeSyncContext.Provider>\n  );\n}\n\nexport function useRealtimeSync() {\n  const context = useContext(RealtimeSyncContext);\n  if (!context) {\n    throw new Error(\"useRealtimeSync must be used within RealtimeSyncProvider\");\n  }\n  return context;\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 3275, "column": 0}, "map": {"version":3,"sources":["file:///mnt/g/files/documents/webdev/algo-app/src/contexts/session-manager-context.tsx"],"sourcesContent":["\"use client\";\n\nimport { createContext, useContext, useEffect, useRef } from \"react\";\nimport { useAuth } from \"@/contexts/auth-context\";\nimport { realtimeDb } from \"@/lib/firebase/config\";\nimport { ref, set, onValue, serverTimestamp } from \"firebase/database\";\n\n// Generate unique session ID for this browser/tab\nfunction generateSessionId(): string {\n  return `${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n}\n\ninterface SessionManagerContextType {\n  currentSessionId: string;\n}\n\nconst SessionManagerContext = createContext<SessionManagerContextType | undefined>(undefined);\n\nexport function SessionManagerProvider({ children }: { children: React.ReactNode }) {\n  const { user, signOut } = useAuth();\n  const sessionIdRef = useRef<string>(generateSessionId());\n  const isLoggingOutRef = useRef(false);\n\n  useEffect(() => {\n    if (!user) return;\n\n    const userSessionRef = ref(realtimeDb, `activeSessions/${user.uid}`);\n    const mySessionId = sessionIdRef.current;\n\n    // Claim this session as active\n    console.log(`[Session] Claiming session for user ${user.email}: ${mySessionId}`);\n    set(userSessionRef, {\n      sessionId: mySessionId,\n      email: user.email,\n      timestamp: Date.now(),\n    });\n\n    // Listen for session changes\n    const unsubscribe = onValue(userSessionRef, (snapshot) => {\n      const data = snapshot.val();\n\n      if (!data) return;\n\n      // If session ID changed and it's not mine, someone else logged in\n      if (data.sessionId !== mySessionId && !isLoggingOutRef.current) {\n        console.log(`[Session] Another device logged in. Logging out this session.`);\n        isLoggingOutRef.current = true;\n\n        // Show alert\n        alert(\"You have been logged out because your account was accessed from another device.\");\n\n        // Force logout\n        signOut();\n      }\n    });\n\n    return () => {\n      unsubscribe();\n    };\n  }, [user, signOut]);\n\n  const value: SessionManagerContextType = {\n    currentSessionId: sessionIdRef.current,\n  };\n\n  return (\n    <SessionManagerContext.Provider value={value}>\n      {children}\n    </SessionManagerContext.Provider>\n  );\n}\n\nexport function useSessionManager() {\n  const context = useContext(SessionManagerContext);\n  if (!context) {\n    throw new Error(\"useSessionManager must be used within SessionManagerProvider\");\n  }\n  return context;\n}\n"],"names":[],"mappings":";;;;;;;AAEA;AACA;AACA;AACA;AAAA;;;AALA;;;;;AAOA,kDAAkD;AAClD,SAAS;IACP,OAAO,GAAG,KAAK,GAAG,GAAG,CAAC,EAAE,KAAK,MAAM,GAAG,QAAQ,CAAC,IAAI,MAAM,CAAC,GAAG,IAAI;AACnE;AAMA,MAAM,sCAAwB,IAAA,8KAAa,EAAwC;AAE5E,SAAS,uBAAuB,EAAE,QAAQ,EAAiC;;IAChF,MAAM,EAAE,IAAI,EAAE,OAAO,EAAE,GAAG,IAAA,iJAAO;IACjC,MAAM,eAAe,IAAA,uKAAM,EAAS;IACpC,MAAM,kBAAkB,IAAA,uKAAM,EAAC;IAE/B,IAAA,0KAAS;4CAAC;YACR,IAAI,CAAC,MAAM;YAEX,MAAM,iBAAiB,IAAA,wKAAG,EAAC,iJAAU,EAAE,CAAC,eAAe,EAAE,KAAK,GAAG,EAAE;YACnE,MAAM,cAAc,aAAa,OAAO;YAExC,+BAA+B;YAC/B,QAAQ,GAAG,CAAC,CAAC,oCAAoC,EAAE,KAAK,KAAK,CAAC,EAAE,EAAE,aAAa;YAC/E,IAAA,wKAAG,EAAC,gBAAgB;gBAClB,WAAW;gBACX,OAAO,KAAK,KAAK;gBACjB,WAAW,KAAK,GAAG;YACrB;YAEA,6BAA6B;YAC7B,MAAM,cAAc,IAAA,4KAAO,EAAC;gEAAgB,CAAC;oBAC3C,MAAM,OAAO,SAAS,GAAG;oBAEzB,IAAI,CAAC,MAAM;oBAEX,kEAAkE;oBAClE,IAAI,KAAK,SAAS,KAAK,eAAe,CAAC,gBAAgB,OAAO,EAAE;wBAC9D,QAAQ,GAAG,CAAC,CAAC,6DAA6D,CAAC;wBAC3E,gBAAgB,OAAO,GAAG;wBAE1B,aAAa;wBACb,MAAM;wBAEN,eAAe;wBACf;oBACF;gBACF;;YAEA;oDAAO;oBACL;gBACF;;QACF;2CAAG;QAAC;QAAM;KAAQ;IAElB,MAAM,QAAmC;QACvC,kBAAkB,aAAa,OAAO;IACxC;IAEA,qBACE,6LAAC,sBAAsB,QAAQ;QAAC,OAAO;kBACpC;;;;;;AAGP;GApDgB;;QACY,iJAAO;;;KADnB;AAsDT,SAAS;;IACd,MAAM,UAAU,IAAA,2KAAU,EAAC;IAC3B,IAAI,CAAC,SAAS;QACZ,MAAM,IAAI,MAAM;IAClB;IACA,OAAO;AACT;IANgB"}},
    {"offset": {"line": 3378, "column": 0}, "map": {"version":3,"sources":["file:///mnt/g/files/documents/webdev/algo-app/src/app/providers.tsx"],"sourcesContent":["\"use client\";\n\nimport { AuthProvider } from \"@/contexts/auth-context\";\nimport { AudioMonitoringProvider } from \"@/contexts/audio-monitoring-context\";\nimport { RealtimeSyncProvider } from \"@/contexts/realtime-sync-context\";\nimport { SessionManagerProvider } from \"@/contexts/session-manager-context\";\nimport { type ReactNode } from \"react\";\n\nexport function Providers({ children }: { children: ReactNode }) {\n  return (\n    <AuthProvider>\n      <SessionManagerProvider>\n        <RealtimeSyncProvider>\n          <AudioMonitoringProvider>\n            {children}\n          </AudioMonitoringProvider>\n        </RealtimeSyncProvider>\n      </SessionManagerProvider>\n    </AuthProvider>\n  );\n}\n"],"names":[],"mappings":";;;;;AAEA;AACA;AACA;AACA;AALA;;;;;;AAQO,SAAS,UAAU,EAAE,QAAQ,EAA2B;IAC7D,qBACE,6LAAC,sJAAY;kBACX,cAAA,6LAAC,8KAAsB;sBACrB,cAAA,6LAAC,0KAAoB;0BACnB,cAAA,6LAAC,gLAAuB;8BACrB;;;;;;;;;;;;;;;;;;;;;AAMb;KAZgB"}}]
}